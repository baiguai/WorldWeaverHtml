<html lang="en"><head>
  <meta charset="UTF-8">
  <title>IF Visual Planner</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: monospace;
      overflow: hidden;
    }
    #toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #222;
      padding: 5px;
      z-index: 10;
    }
    #toolbar button {
      margin-right: 5px;
      border: solid 1px #444;
      background: #222;
      color: #ddd;
    }
    #canvas {
      position: absolute;
      top: 35px;
      left: 0;
      right: 0;
      bottom: 0;
      background: black;
      transform-origin: 0 0;
      overflow-x: auto;
      overflow-y: auto;
    }
    .zoom-controls {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 10;
    }
    .zoom-controls button {
      background: #333;
      color: white;
      border: 1px solid #666;
      margin-left: 2px;
      cursor: pointer;
    }
    .node {
      position: absolute;
      border: 1px solid white;
      background: #111;
      color: white;
      cursor: move;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 100px;
      min-height: 60px;
    }
    .node-header {
      font-weight: bold;
      padding: 3px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .delete-btn {
      background: none;
      border: none;
      color: red;
      cursor: pointer;
      font-size: 16px;
    }
    .node-content {
      flex: 1;
      background: #111;
      color: white;
      border: none;
      resize: none;
      font-family: monospace;
      padding: 4px;
      font-size: 12px;
    }
    .dropzone {
      flex: 1;
      /* border-top: 1px dashed gray; */
      background: #111;
      padding: 4px;
      overflow: auto;
    }
    .connector {
      position: absolute;
      pointer-events: none;
      z-index: 0;
    }
  </style>
<style type="text/css" id="operaUserStyle"></style></head>
<body>
  <div id="toolbar">
    <button onclick="addNode('Room')">Add Room</button>
    <button onclick="addNode('Item/NPC')">Add Item/NPC</button>
    <button onclick="addNode('Note')">Add Note</button>
    <button onclick="startConnector()">Room Connector</button>
    <button onclick="download()">Save</button>
  </div>
  <div id="canvas" tabindex="0"></div>
  <div class="zoom-controls">
    <button onclick="setZoom(zoom + 0.1)">Zoom In</button>
    <button onclick="setZoom(zoom - 0.1)">Zoom Out</button>
  </div>

<script>
let canvas = document.getElementById('canvas');
let selectedNode = null;
let offsetX, offsetY;
let nodes = [];
let connectors = [];
let connecting = false;
let connectStart = null;
let focusedNode = null;
let zoom = 1;

function setZoom(z) {
  zoom = Math.max(0.2, Math.min(z, 3));
  canvas.style.transform = `scale(${zoom})`;
}

function findEmptySpot() {
  const spacing = 20;
  const width = 150;
  const height = 100;
  const maxCols = Math.floor(canvas.clientWidth / (width + spacing));
  const maxRows = Math.floor(canvas.clientHeight / (height + spacing));

  for (let row = 0; row < maxRows; row++) {
    for (let col = 0; col < maxCols; col++) {
      const left = col * (width + spacing);
      const top = row * (height + spacing);
      const overlap = nodes.some(n => {
        const nLeft = parseInt(n.style.left);
        const nTop = parseInt(n.style.top);
        const nRight = nLeft + parseInt(n.style.width);
        const nBottom = nTop + parseInt(n.style.height);
        return (
          left < nRight &&
          left + width > nLeft &&
          top < nBottom &&
          top + height > nTop
        );
      });
      if (!overlap) return { left, top };
    }
  }
  return { left: 100, top: 100 };
}

function addNode(type) {
  let div = document.createElement('div');
  div.className = 'node';
  const { left, top } = findEmptySpot();
  div.style.left = left + 'px';
  div.style.top = top + 'px';
  div.style.width = '150px';
  div.style.height = '100px';
  div.dataset.type = type;
  div.id = 'node-' + nodes.length;

  const header = document.createElement('div');
  header.className = 'node-header';
  header.textContent = type;

  const deleteBtn = document.createElement('button');
  deleteBtn.innerHTML = 'ðŸ—‘ï¸';
  deleteBtn.className = 'delete-btn';
  deleteBtn.onclick = e => {
    e.stopPropagation();
    removeNode(div);
  };
  header.appendChild(deleteBtn);
  div.appendChild(header);

  const textarea = document.createElement('textarea');
  textarea.className = 'node-content';
  textarea.placeholder = 'Enter notes...';
  div.appendChild(textarea);

  if (type === 'Room' || type === 'Item/NPC') {
    const dropzone = document.createElement('div');
    dropzone.className = 'dropzone';
    dropzone.ondragover = e => e.preventDefault();
    dropzone.ondrop = e => {
      const id = e.dataTransfer.getData("text/plain");
      const item = document.getElementById(id);
      if (item) dropzone.appendChild(item);
    };
    div.appendChild(dropzone);
  }

  setupNode(div);
  canvas.appendChild(div);
  nodes.push(div);
}

function setupNode(div) {
  const type = div.dataset.type;
  const textarea = div.querySelector('textarea');
//  if (textarea) textarea.value = textarea.textContent;

  const header = div.querySelector('.node-header');
  const deleteBtn = header?.querySelector('.delete-btn');
  if (deleteBtn) {
    deleteBtn.onclick = e => {
      e.stopPropagation();
      removeNode(div);
    };
  }

  function setSelectedNode(node) {
    selectedNode = node;
    nodes.forEach(n => {
      n.style.borderColor = (n === selectedNode) ? '#00ff00' : 'white';
    });
  }

  const headerEl = div.querySelector('.node-header');
  headerEl.style.cursor = 'move';
  headerEl.onmousedown = e => {
    if (!connecting) {
      selectedNode = div;
      setSelectedNode(div);
      offsetX = e.offsetX;
      offsetY = e.offsetY;
      focusedNode = div;
      e.stopPropagation();
    }
  };

  div.onclick = e => {
    if (connecting && type === 'Room') {
      if (!connectStart) {
        connectStart = div;
      } else {
        drawConnector(connectStart, div);
        connectStart = null;
        connecting = false;
      }
      e.stopPropagation();
    }
    focusedNode = div;
  };

  div.draggable = true;
  div.ondragstart = e => {
    e.dataTransfer.setData("text/plain", div.id);
  };

  const dropzone = div.querySelector('.dropzone');
  if (dropzone) {
    dropzone.ondragover = e => e.preventDefault();
    dropzone.ondrop = e => {
      const id = e.dataTransfer.getData("text/plain");
      const item = document.getElementById(id);
      if (item) dropzone.appendChild(item);
    };
  }

  if (!nodes.includes(div)) nodes.push(div);
}

function removeNode(node) {
  connectors = connectors.filter(c => c.a !== node && c.b !== node);
  updateConnectors();
  if (node.parentElement) {
    node.parentElement.removeChild(node);
  }
  nodes = nodes.filter(n => n !== node);
  if (focusedNode === node) focusedNode = null;
}

canvas.onmousemove = e => {
  if (selectedNode) {
    const parentRect = selectedNode.parentElement.getBoundingClientRect();
    const newLeft = (e.clientX - parentRect.left) / zoom - offsetX;
    const newTop = (e.clientY - parentRect.top) / zoom - offsetY;
    selectedNode.style.left = newLeft + 'px';
    selectedNode.style.top = newTop + 'px';
    updateConnectors();
  }
};

canvas.onmouseup = () => {
  if (selectedNode) {
    // Only consider attaching if this is NOT a Room node
    if (selectedNode.dataset.type !== 'Room') {
      const selectedRect = selectedNode.getBoundingClientRect();

      for (let node of nodes) {
        if (node === selectedNode) continue;
        if (node.dataset.type !== 'Room') continue;

        const nodeRect = node.getBoundingClientRect();
        const overlap = !(
          selectedRect.right < nodeRect.left ||
          selectedRect.left > nodeRect.right ||
          selectedRect.bottom < nodeRect.top ||
          selectedRect.top > nodeRect.bottom
        );

        if (overlap) {
          const dropzone = node.querySelector('.dropzone');
          if (dropzone && !dropzone.contains(selectedNode)) {
            // Remove from canvas if not already removed
            if (selectedNode.parentElement === canvas) {
              canvas.removeChild(selectedNode);
            } else {
              selectedNode.parentElement.removeChild(selectedNode);
            }

            // Adjust relative position
            const parentRect = dropzone.getBoundingClientRect();
            const newLeft = selectedRect.left - parentRect.left;
            const newTop = selectedRect.top - parentRect.top;

            selectedNode.style.left = newLeft + 'px';
            selectedNode.style.top = newTop + 'px';

            dropzone.appendChild(selectedNode);
          }
          break;
        }
      }
    }

    selectedNode = null;
    updateConnectors();
  }
};

canvas.addEventListener('keydown', e => {
  if (!focusedNode || ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

  const step = 10;
  let style = focusedNode.style;
  let width = parseInt(style.width);
  let height = parseInt(style.height);
  let left = parseInt(style.left);
  let top = parseInt(style.top);

  if (e.ctrlKey) {
    switch (e.key) {
      case 'ArrowRight': style.width = (width + step) + 'px'; break;
      case 'ArrowLeft':  style.width = Math.max(50, width - step) + 'px'; break;
      case 'ArrowDown':  style.height = (height + step) + 'px'; break;
      case 'ArrowUp':    style.height = Math.max(40, height - step) + 'px'; break;
    }
  } else {
    switch (e.key) {
      case 'ArrowRight': style.left = (left + step) + 'px'; break;
      case 'ArrowLeft':  style.left = (left - step) + 'px'; break;
      case 'ArrowDown':  style.top = (top + step) + 'px'; break;
      case 'ArrowUp':    style.top = (top - step) + 'px'; break;
    }
  }
  updateConnectors();
  e.preventDefault();
});

function drawConnector(a, b) {
  connectors.push({a, b});
  updateConnectors();
}

function updateConnectors() {
  document.querySelectorAll('svg.connector').forEach(c => c.remove());
  connectors.forEach(({a, b}) => {
    let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.classList.add("connector");
    svg.style.position = 'absolute';
    svg.style.left = 0;
    svg.style.top = 0;
    svg.style.width = '100%';
    svg.style.height = '100%';

    let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    let ax = a.offsetLeft + a.offsetWidth / 2;
    let ay = a.offsetTop + a.offsetHeight / 2;
    let bx = b.offsetLeft + b.offsetWidth / 2;
    let by = b.offsetTop + b.offsetHeight / 2;

    line.setAttribute("x1", ax);
    line.setAttribute("y1", ay);
    line.setAttribute("x2", bx);
    line.setAttribute("y2", by);
    line.setAttribute("stroke", "white");
    line.setAttribute("stroke-width", "2");
    svg.appendChild(line);
    canvas.insertBefore(svg, canvas.firstChild);
  });
}

function startConnector() {
  connecting = true;
  connectStart = null;
}

function download() {
  document.querySelectorAll('textarea.node-content').forEach(t => {
    t.textContent = t.value;
  });

  let html = document.documentElement.outerHTML;
  let blob = new Blob([html], {type: 'text/html'});
  let a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'if-visual-planner.html';
  a.click();
}

function initializeNodes() {
  document.querySelectorAll('.node').forEach(setupNode);
}

function restoreConnectorsFromDOM() {
  const lines = document.querySelectorAll('svg.connector line');
  lines.forEach(line => {
    const [x1, y1, x2, y2] = ['x1','y1','x2','y2'].map(attr => parseFloat(line.getAttribute(attr)));
    let nodeA = null, nodeB = null;

    for (const n of nodes) {
      const cx = n.offsetLeft + n.offsetWidth / 2;
      const cy = n.offsetTop + n.offsetHeight / 2;
      if (Math.abs(cx - x1) < 10 && Math.abs(cy - y1) < 10) nodeA = n;
      if (Math.abs(cx - x2) < 10 && Math.abs(cy - y2) < 10) nodeB = n;
    }

    if (nodeA && nodeB) {
      connectors.push({ a: nodeA, b: nodeB });
    }
  });

  updateConnectors();
}

window.onload = () => {
  initializeNodes();
  restoreConnectorsFromDOM();
};
</script>


</body></html>
