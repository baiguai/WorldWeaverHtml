<html lang="en"><head>
  <meta charset="UTF-8">
  <title>IF Visual Planner</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: monospace;
      overflow: auto;
    }
    #toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #222;
      padding: 5px;
      z-index: 10;
    }
    #toolbar button {
      margin-right: 5px;
      border: solid 1px #444;
      background: #222;
      color: #ddd;
    }
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: black;
      transform-origin: 0 0;
      overflow-x: auto;
      overflow-y: auto;
      min-width: 500000px;
      min-height: 500000px;
    }
    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      right: 0;
      bottom: 0;
      cursor: se-resize;
      background: #444;
      z-index: 2;
    }
    .zoom-controls {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 10;
    }
    .zoom-controls button {
      background: #333;
      color: white;
      border: 1px solid #666;
      margin-left: 2px;
      cursor: pointer;
    }
    .node {
      position: absolute;
      border: 1px solid white;
      background: #111;
      color: white;
      cursor: move;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 100px;
      min-height: 60px;
    }
    .node-header {
      font-weight: bold;
      padding: 3px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .delete-btn {
      background: none;
      border: none;
      color: red;
      cursor: pointer;
      font-size: 16px;
    }
    .node-content {
      background: #111;
      color: white;
      border: none;
      resize: none;
      font-family: monospace;
      padding: 4px;
      font-size: 12px;
      height: 150px;
    }
    .dropzone {
      position: relative; /* Add this line */
      border-top: 1px dashed gray;
      flex: 1;
      background: #111;
      padding: 4px;
      overflow: auto;
    }
    .connector {
      position: absolute;
      pointer-events: none;
      z-index: 0;
    }
  </style>
<style type="text/css" id="operaUserStyle"></style></head>
<body>
  <div id="toolbar" style="display: none; height: 0px;">
    <button onclick="addNode('Room')">Add Room</button>
    <button onclick="addNode('Item/NPC')">Add Item/NPC</button>
    <button onclick="addNode('Note')">Add Note</button>
    <button onclick="startConnector()">Room Connector</button>
    <button onclick="download()">Save</button>
  </div>
  <div id="canvas" tabindex="0"></div>
  <div class="zoom-controls">
    <button onclick="setZoom(zoom + 0.1)">Zoom In</button>
    <button onclick="setZoom(zoom - 0.1)">Zoom Out</button>
  </div>

  <div id="helpDialog" style="
    display: none;
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: #222;
    color: white;
    border: 2px solid #555;
    padding: 20px;
    z-index: 9999;
    font-family: monospace;
    max-width: 400px;
    text-align: left;
  ">
    <h3>Shortcut Keys</h3>
    <p>
      <pre>
a = Add a new node.
c = Start connection (select a room and hit Enter,
    select the second room and hit Enter).
D = Delete the selected node.
h = Move selected node left.
H = Reduce width of selected node.
i = Select current node's text field.
j = Move selected node down.
J = Increase selected node's height.
k = Move selected node up.
K = Reduce selected node's height.
l = Move selected node right.
L = Increase selected node's width.
< = Move selected node left by half a step.
> = Move selected node right by half a step.
^ = Move selected node up by half a step.
- = Move selected node down by half a step.
z = Increase selected node's text area.
Z = Decrease selected node's text area.
w = Cycles through the nodes.
Enter = When connecting rooms sets the first
    or second room. When the current node
    is not a room, but is on top of one,
    sets it as a child of the room.
      </pre>
    </p>
    <p>Press ESC to close.</p>
  </div>

<script>
let canvas = document.getElementById('canvas');
let selectedNode = null;
let offsetX, offsetY;
let nodes = [];
let connectors = [];
let connecting = false;
let connectStart = null;
let focusedNode = null;
let zoom = 1;
let dragging = false;

function setZoom(z) {
  zoom = Math.max(0.2, Math.min(z, 3));
  canvas.style.transform = `scale(${zoom})`;
}

function findEmptySpot() {
  const step = 40; // Movement step and spacing
  const width = 160; // Rounded to nearest multiple of 40
  const height = 120; // Rounded to nearest multiple of 40
  const maxCols = Math.floor(canvas.clientWidth / (width + step));
  const maxRows = Math.floor(canvas.clientHeight / (height + step));

  for (let row = 0; row < maxRows; row++) {
    for (let col = 0; col < maxCols; col++) {
      const left = col * (width + step);
      const top = row * (height + step);

      // Snap to nearest multiple of step
      const snappedLeft = Math.round(left / step) * step;
      const snappedTop = Math.round(top / step) * step;

      const overlap = nodes.some(n => {
        const nLeft = Math.round(parseInt(n.style.left) / step) * step;
        const nTop = Math.round(parseInt(n.style.top) / step) * step;
        const nRight = nLeft + Math.round(parseInt(n.style.width) / step) * step;
        const nBottom = nTop + Math.round(parseInt(n.style.height) / step) * step;
        return (
          snappedLeft < nRight &&
          snappedLeft + width > nLeft &&
          snappedTop < nBottom &&
          snappedTop + height > nTop
        );
      });

      if (!overlap) return { left: snappedLeft, top: snappedTop };
    }
  }

  return {
    left: Math.round(100 / step) * step,
    top: Math.round(100 / step) * step
  };
}

function addNode() {
  const input = prompt("Enter node type:");
  if (!input) return; // Cancelled or empty
  const type = input.trim();

  let div = document.createElement('div');
  div.className = 'node';
  div.style.width = '150px';
  div.style.height = '100px';
  div.dataset.type = type;
  div.id = 'node-' + nodes.length;

  const header = document.createElement('div');
  header.className = 'node-header';
  header.textContent = type;

  const deleteBtn = document.createElement('button');
  deleteBtn.innerHTML = 'ðŸ—‘ï¸';
  deleteBtn.className = 'delete-btn';
  deleteBtn.onclick = e => {
    e.stopPropagation();
    removeNode(div);
  };
  header.appendChild(deleteBtn);
  div.appendChild(header);

  const textarea = document.createElement('textarea');
  textarea.className = 'node-content';
  textarea.placeholder = 'Enter notes...';
  div.appendChild(textarea);

  const resizeHandle = document.createElement('div');
  resizeHandle.className = 'resize-handle';
  div.appendChild(resizeHandle);

  const dropzone = document.createElement('div');
  dropzone.className = 'dropzone';
  dropzone.ondragover = e => e.preventDefault();
  dropzone.ondrop = e => {
    const id = e.dataTransfer.getData("text/plain");
    const item = document.getElementById(id);
    if (item && !item.contains(div)) dropzone.appendChild(item);
  };
  div.appendChild(dropzone);

  setupNode(div);

  // === Nesting logic ===
  if (selectedNode) {
    const parentDropzone = selectedNode.querySelector('.dropzone');
    if (parentDropzone && !div.contains(parentDropzone)) {
      div.style.left = '10px';
      div.style.top = '10px';
      parentDropzone.appendChild(div);
    } else {
      const { left, top } = findEmptySpot();
      div.style.left = left + 'px';
      div.style.top = top + 'px';
      canvas.appendChild(div);
    }
  } else {
    const { left, top } = findEmptySpot();
    div.style.left = left + 'px';
    div.style.top = top + 'px';
    canvas.appendChild(div);
  }

  nodes.push(div);

  // Resizing logic
  if (resizeHandle) {
    let resizing = false;
    let startX, startY, startWidth, startHeight;

    resizeHandle.onmousedown = e => {
      e.stopPropagation();
      resizing = true;
      startX = e.clientX;
      startY = e.clientY;
      startWidth = parseInt(getComputedStyle(div).width, 10);
      startHeight = parseInt(getComputedStyle(div).height, 10);
      document.body.style.cursor = 'se-resize';

      document.onmousemove = e => {
        if (resizing) {
          const newWidth = Math.max(100, startWidth + (e.clientX - startX) / zoom);
          const newHeight = Math.max(60, startHeight + (e.clientY - startY) / zoom);
          div.style.width = newWidth + 'px';
          div.style.height = newHeight + 'px';
          updateConnectors();
        }
      };

      document.onmouseup = () => {
        resizing = false;
        document.body.style.cursor = 'default';
        document.onmousemove = null;
        document.onmouseup = null;
      };
    };
  }

  attachChild(div); // Check for drop if it's floating
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function getAllNodes() {
  return Array.from(document.querySelectorAll('.node'));
}

function setFocusedNode(node) {
  focusedNode = node;
  getAllNodes().forEach(n => n.style.borderColor = (n === node) ? '#00ff00' : 'white');
}

function setSelectedNode(node) {
  selectedNode = node;
  nodes.forEach(n => {
    n.style.borderColor = (n === selectedNode) ? '#00ff00' : 'white';
  });
}

function setupNode(div) {
  const type = div.dataset.type;
  const textarea = div.querySelector('textarea');
//  if (textarea) textarea.value = textarea.textContent;

  const header = div.querySelector('.node-header');
  const deleteBtn = header?.querySelector('.delete-btn');
  if (deleteBtn) {
    deleteBtn.onclick = e => {
      e.stopPropagation();
      removeNode(div);
    };
  }

  const headerEl = div.querySelector('.node-header');
  headerEl.style.cursor = 'move';
  headerEl.onmousedown = e => {
    if (!connecting) {
      dragging = true;
      selectedNode = div;
      setSelectedNode(div);
      offsetX = e.offsetX;
      offsetY = e.offsetY;
      focusedNode = div;
      e.stopPropagation();
    }
  };

  div.onclick = e => {
    if (connecting) {
      if (!connectStart) {
        connectStart = div;
      } else {
        drawConnector(connectStart, div);
        connectStart = null;
        connecting = false;
      }
      e.stopPropagation();
    }
    focusedNode = div;
  };

  div.draggable = true;
  div.ondragstart = e => {
    e.dataTransfer.setData("text/plain", div.id);
  };

  const dropzone = div.querySelector('.dropzone');
  if (dropzone) {
    dropzone.ondragover = e => e.preventDefault();
    dropzone.ondrop = e => {
      const id = e.dataTransfer.getData("text/plain");
      const item = document.getElementById(id);
      if (item) dropzone.appendChild(item);
    };
  }

  if (!nodes.includes(div)) nodes.push(div);


const resizeHandle = div.querySelector('.resize-handle');
if (resizeHandle) {
  let resizing = false;
  let startX, startY, startWidth, startHeight;

  resizeHandle.onmousedown = e => {
    e.stopPropagation();
    resizing = true;
    startX = e.clientX;
    startY = e.clientY;
    startWidth = parseInt(document.defaultView.getComputedStyle(div).width, 10);
    startHeight = parseInt(document.defaultView.getComputedStyle(div).height, 10);
    document.body.style.cursor = 'se-resize';

    document.onmousemove = e => {
      if (resizing) {
        const newWidth = Math.max(100, startWidth + (e.clientX - startX) / zoom);
        const newHeight = Math.max(60, startHeight + (e.clientY - startY) / zoom);
        div.style.width = newWidth + 'px';
        div.style.height = newHeight + 'px';
        updateConnectors();
      }
    };

    document.onmouseup = () => {
      resizing = false;
      document.body.style.cursor = 'default';
      document.onmousemove = null;
      document.onmouseup = null;
    };
  };
}
}

function removeNode(node) {
  connectors = connectors.filter(c => c.a !== node && c.b !== node);
  updateConnectors();
  if (node.parentElement) {
    node.parentElement.removeChild(node);
  }
  nodes = nodes.filter(n => n !== node);
  if (focusedNode === node) focusedNode = null;
}

canvas.onmousemove = e => {
  if (selectedNode && dragging) {
    const parentRect = selectedNode.parentElement.getBoundingClientRect();
    const newLeft = (e.clientX - parentRect.left) / zoom - offsetX;
    const newTop = (e.clientY - parentRect.top) / zoom - offsetY;
    selectedNode.style.left = newLeft + 'px';
    selectedNode.style.top = newTop + 'px';
    updateConnectors();
  }
};

canvas.onmouseup = () => {
  if (selectedNode) {
    attachChild(selectedNode);
    dragging = false;

    updateConnectors();
  }
};

function attachChild(selectedNode) {
  const selectedRect = selectedNode.getBoundingClientRect();

  for (let node of nodes) {
    if (node === selectedNode) continue;

    const nodeRect = node.getBoundingClientRect();
    const overlap = !(
      selectedRect.right < nodeRect.left ||
      selectedRect.left > nodeRect.right ||
      selectedRect.bottom < nodeRect.top ||
      selectedRect.top > nodeRect.bottom
    );

    if (overlap) {
      const dropzone = node.querySelector('.dropzone');
      if (dropzone && !dropzone.contains(selectedNode)) {
        // Remove from canvas if not already removed
        if (selectedNode.parentElement === canvas) {
          canvas.removeChild(selectedNode);
        } else {
          selectedNode.parentElement.removeChild(selectedNode);
        }

        // Adjust relative position
        const parentRect = dropzone.getBoundingClientRect();
        const newLeft = selectedRect.left - parentRect.left;
        const newTop = selectedRect.top - parentRect.top;

        selectedNode.style.left = newLeft + 'px';
        selectedNode.style.top = newTop + 'px';

        dropzone.appendChild(selectedNode);
      }
      break;
    }
  }
}

canvas.onclick = e => {
  // Only unselect if clicking on the canvas, not on a node
  if (e.target === canvas) {
    setSelectedNode(null);
  }
};

document.addEventListener('keydown', e => {
  if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

  if (e.key === '?' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
    document.getElementById('helpDialog').style.display = 'block';
    e.preventDefault();
    return;
  }

  if (e.key === 'Escape') {
    document.getElementById('helpDialog').style.display = 'none';
    return;
  }

  switch (e.key) {
    case 'a':
      addNode();
      break;
    case 's':
      download();
      break;
  }

  if (e.key === 'w' || e.key === 'W') {
    const nodes = getAllNodes();
    if (nodes.length === 0) return;

    const index = nodes.indexOf(focusedNode);
    let nextIndex;
    if (e.shiftKey) {
      nextIndex = (index - 1 + nodes.length) % nodes.length;
    } else {
      nextIndex = (index + 1) % nodes.length;
    }

    setFocusedNode(nodes[nextIndex]);
    return;
  }

  if (!focusedNode) {
    return;
  }

  const step = 40;
  const style = focusedNode.style;
  const width = parseInt(style.width);
  const height = parseInt(style.height);
  const left = parseInt(style.left);
  const top = parseInt(style.top);
  const dropzone = focusedNode.querySelector('.dropzone');
  const textarea = focusedNode.querySelector('textarea');

  const resize = (dw, dh) => {
    const width = parseInt(focusedNode.style.width);
    const height = parseInt(focusedNode.style.height);
    focusedNode.style.width = Math.max(50, width + dw) + 'px';
    focusedNode.style.height = Math.max(40, height + dh) + 'px';
  };

  const resizeDropzone = (dh) => {
    if (!dropzone) return;
    const dzStyle = dropzone.style;
    const txStyle = textarea.style;
    const dzWidth = parseFloat(dzStyle.width) || 0;
    const dzHeight = parseFloat(dzStyle.height) || 0;
    dzStyle.height = Math.max(10, dzHeight + dh) + 'px';
    txStyle.height = Math.max(10, dzHeight - dh) + 'px';
  };
  
  const move = (dx, dy) => {
    const parent = focusedNode.offsetParent;
    const currentLeft = focusedNode.offsetLeft;
    const currentTop = focusedNode.offsetTop;
    focusedNode.style.left = (currentLeft + dx) + 'px';
    focusedNode.style.top = (currentTop + dy) + 'px';
    updateConnectors();
  };

  switch (e.key) {
    case 'c':
      startConnector()
      break;
    case 'D':
      removeNode(focusedNode);
      break;
    case 'h':
      move(-step, 0);
      break;
    case '<':
      move(-(step/2), 0);
      break;
    case 'H':
      resize(-step, 0);
      break;
    case 'i':
      if (textarea) {
        textarea.focus();
        e.preventDefault();
      }
      break;
    case 'j':
      move(0, step);
      break;
    case '-':
      move(0, (step/2));
      break;
    case 'J':
      resize(0, step);
      break;
    case 'k':
      move(0, -step);
      break;
    case '^':
      move(0, -(step/2));
      break;
    case 'K':
      resize(0, -step);
      break;
    case 'l':
      move(step, 0);
      break;
    case '>':
      move((step/2), 0);
      break;
    case 'L':
      resize(step, 0);
      break;
    case 'm':
      resize(step, step);
      break;
    case 'z':
      resizeDropzone(10);
      break;
    case 'Z':
      resizeDropzone(-10);
      break;
    case 'Enter':
      if (!connecting) {
        attachChild(focusedNode);
      } else {
        if (!connectStart) {
          connectStart = focusedNode;
        } else {
          drawConnector(connectStart, focusedNode);
          connectStart = null;
          connecting = false;
        }
        e.stopPropagation();
      }
      break;
    default:
      return; // Don't prevent default for unrelated keys
  }

  e.preventDefault();
});

function drawConnector(a, b) {
  connectors.push({a, b});
  updateConnectors();
}

function updateConnectors() {
  // Remove old connectors
  document.querySelectorAll('svg.connector').forEach(c => c.remove());

  // Utility to get ancestors up to #canvas
  function getAncestors(node) {
    const ancestors = [];
    while (node && node !== canvas) {
      ancestors.push(node);
      node = node.parentElement;
    }
    if (node === canvas) ancestors.push(canvas);
    return ancestors.reverse(); // from canvas down to node
  }

  // Find lowest common ancestor
  function findLCA(a, b) {
    const aAncestors = getAncestors(a);
    const bAncestors = getAncestors(b);
    let lca = canvas;
    for (let i = 0; i < Math.min(aAncestors.length, bAncestors.length); i++) {
      if (aAncestors[i] === bAncestors[i]) {
        lca = aAncestors[i];
      } else {
        break;
      }
    }
    return lca;
  }

  connectors.forEach(({ a, b }) => {
    const lca = findLCA(a, b);
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.classList.add("connector");
    svg.style.position = 'absolute';
    svg.style.left = 0;
    svg.style.top = 0;
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.zIndex = '0';

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

    const lcaRect = lca.getBoundingClientRect();
    const aRect = a.getBoundingClientRect();
    const bRect = b.getBoundingClientRect();

    const ax = aRect.left + aRect.width / 2 - lcaRect.left;
    const ay = aRect.top + aRect.height / 2 - lcaRect.top;
    const bx = bRect.left + bRect.width / 2 - lcaRect.left;
    const by = bRect.top + bRect.height / 2 - lcaRect.top;

    line.setAttribute("x1", ax);
    line.setAttribute("y1", ay);
    line.setAttribute("x2", bx);
    line.setAttribute("y2", by);
    line.setAttribute("stroke", "white");
    line.setAttribute("stroke-width", "2");
    svg.appendChild(line);

    // Determine the lowest index of a or b within the LCA to insert before
    let insertBefore = null;
    const lcaDescendants = Array.from(lca.querySelectorAll('.node'));

    const aIndex = lcaDescendants.indexOf(a);
    const bIndex = lcaDescendants.indexOf(b);

    if (aIndex !== -1 && bIndex !== -1) {
      insertBefore = lcaDescendants[Math.min(aIndex, bIndex)];
    } else if (aIndex !== -1) {
      insertBefore = lcaDescendants[aIndex];
    } else if (bIndex !== -1) {
      insertBefore = lcaDescendants[bIndex];
    }

    if (insertBefore && insertBefore.parentElement === lca) {
      lca.insertBefore(svg, insertBefore);
    } else {
      lca.appendChild(svg);
    }
  });
}

function startConnector() {
  connecting = true;
  connectStart = null;
}

function download() {
  document.querySelectorAll('textarea.node-content').forEach(t => {
    t.textContent = t.value;
  });

  let html = document.documentElement.outerHTML;
  let blob = new Blob([html], {type: 'text/html'});
  let a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'plotter.html';
  a.click();
}

function initializeNodes() {
  document.querySelectorAll('.node').forEach(setupNode);
}

function restoreConnectorsFromDOM() {
  const lines = document.querySelectorAll('svg.connector line');
  lines.forEach(line => {
    const [x1, y1, x2, y2] = ['x1','y1','x2','y2'].map(attr => parseFloat(line.getAttribute(attr)));
    let nodeA = null, nodeB = null;

    for (const n of nodes) {
      const cx = n.offsetLeft + n.offsetWidth / 2;
      const cy = n.offsetTop + n.offsetHeight / 2;
      if (Math.abs(cx - x1) < 10 && Math.abs(cy - y1) < 10) nodeA = n;
      if (Math.abs(cx - x2) < 10 && Math.abs(cy - y2) < 10) nodeB = n;
    }

    if (nodeA && nodeB) {
      connectors.push({ a: nodeA, b: nodeB });
    }
  });

  updateConnectors();
}

window.onload = () => {
  initializeNodes();
  restoreConnectorsFromDOM();
  canvas.focus();
};
</script>


</body></html>
