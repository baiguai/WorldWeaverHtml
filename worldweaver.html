<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WorldWeaver</title>

    <!--
        Formatting notes:
        This code is formatted for indentation level folding.
        There are sections indented between comments, so that they
        remain collapsed at certain levels, to make code navigation
        and reading easier.


        Sample Game Notes:
        ------------------------------------------------------------------------

        ROOMS:
        - Gold Room
        - Putting
        - Fight
        - Arming
        - Npc Follow
        - Npc Path
        - Tests Room
        - Output Logic Test 01
        - Dev Note
        - Conversation Room
        - Die Room
        - Spawn Room
        - Ammo Room

    -->

    <!-- Styles -->
        <style>
            html, body {
                height: 100%;
                margin: 0;
                padding: 0;
            }

            body {
                background-color: black;
                color: white;
                font-family: monospace;
                display: flex;
                flex-direction: column;
                height: 100dvh; /* better on mobile than 100vh */
                overflow: hidden;
            }

            #game-interface {
                display: flex;
                flex-direction: column;
                flex: 1;
                min-height: 0; /* Allows flex children to shrink properly */
            }

            #output {
                flex: 1;
                padding: 10px;
                overflow-y: auto;
                white-space: pre-wrap;
                border-bottom: 1px solid white;
                min-height: 0;
            }

            #input-container {
                display: flex;
                padding: 10px;
                background: black;
                border-top: 1px solid white;
            }

            #input {
                flex: 1;
                background: black;
                color: white;
                border: none;
                padding: 10px;
                font-size: 1rem;
                font-family: monospace;
            }

            #input:focus {
                outline: none;
            }

            .link {
                cursor: pointer;
                text-decoration: underline;
            }
        </style>
    <!-- End Styles -->
</head>
<body>
    <div id="game-interface" style="display: none;">
        <div id="output"></div>
        <div id="input-container">
            <input type="text" id="input" autofocus="">
        </div>
    </div>
    <div id="fight-interface" style="display: none; flex-direction: column; flex: 1; padding: 20px; position: relative;">
        <div style="position: absolute; top: 20px; left: 20px;">
            <div>Player Life: <span id="player-life">0</span></div>
            <div>Enemy Life: <span id="enemy-life">0</span></div>
        </div>

        <div id="fight-message" style="
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.5em;
            text-align: center;
            z-index: 10;
        ">
        </div>

        <div style="flex: 1; display: flex; justify-content: center; align-items: center;">
            <div style="margin-right: 50px;">
<?xml version="1.0" encoding="UTF-8" standalone="no"?> <svg width="24mm" height="48mm" viewBox="0 0 24 48" version="1.1" id="svg130" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><defs id="defs127" /><g id="layer1"><path style="fill:#ffffff;stroke-width:0.0108946;fill-opacity:1" d="M 9.9604001,38.69619 C 9.1735285,38.629484 8.4623604,38.17153 8.0843307,37.488105 7.9507341,37.24658 7.870335,37.011109 7.8200355,36.714041 7.8017565,36.606089 7.8004786,36.372934 7.7973387,32.574079 l -0.00333,-4.025568 -1.4102125,-1.127595 -1.4102126,-1.127595 0.00318,-1.710457 c 0.00338,-1.820078 0.00238,-1.781662 0.056602,-2.168033 0.1429605,-1.018659 0.5499296,-2.002058 1.1722421,-2.832605 0.8195195,-1.093743 1.9706849,-1.887415 3.2876982,-2.266707 0.092367,-0.0266 0.1692362,-0.04966 0.1708214,-0.05125 0.00158,-0.0016 -0.04911,-0.03224 -0.1126549,-0.06811 -0.9459878,-0.534086 -1.638575,-1.430681 -1.901845,-2.462049 -0.09383,-0.367586 -0.1212933,-0.594871 -0.1211102,-1.002307 1.525e-4,-0.336912 0.013863,-0.486067 0.071107,-0.773519 0.2291196,-1.150525 0.9535944,-2.135622 1.9905447,-2.70662 0.4477091,-0.246532 0.9425221,-0.4021994 1.4783391,-0.4650843 0.208138,-0.024428 0.663432,-0.024428 0.871571,0 0.660553,0.077524 1.244326,0.2908173 1.781273,0.6508233 1.348343,0.904022 2.004513,2.502753 1.683019,4.100603 -0.22342,1.110414 -0.941096,2.090095 -1.947257,2.658153 -0.06354,0.03588 -0.114249,0.06652 -0.112675,0.06809 0.0016,0.0016 0.0858,0.02703 0.187163,0.05657 0.851626,0.248175 1.600864,0.64847 2.292414,1.224765 0.197027,0.164191 0.577186,0.542335 0.740962,0.737037 0.779499,0.926689 1.263046,2.014057 1.415711,3.183554 0.04772,0.365587 0.0475,0.356369 0.05108,2.122134 l 0.0035,1.70501 -1.356182,1.083526 -1.356183,1.083526 -9e-6,4.004269 c -6e-6,2.579841 -0.0039,4.0469 -0.01089,4.12411 -0.09012,0.992235 -0.817878,1.817908 -1.809776,2.05328 -0.256853,0.06095 -0.191317,0.05882 -1.87805,0.06106 -0.856863,0.0011 -1.605543,-0.002 -1.6637348,-0.0069 z" id="path266" /></g></svg>
            </div>
            <div style="margin-left: 50px;">
<?xml version="1.0" encoding="UTF-8" standalone="no"?> <svg width="24mm" height="48mm" viewBox="0 0 24 48" version="1.1" id="svg130" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><defs id="defs127" /><g id="layer1"><path style="fill:#ffffff;stroke-width:0.0404355;fill-opacity:1" d="m 2.4287764,35.493786 0.00823,-0.960343 0.7986009,-0.01096 0.7986008,-0.01096 V 33.62279 32.734064 h 0.626095 0.6260953 l 0.01145,-8.380254 0.01145,-8.380255 0.090076,-0.26283 C 5.708615,14.808398 6.5057076,14.151126 7.3987593,14.062059 l 0.2948604,-0.02941 0.011162,-0.616641 0.011162,-0.616641 h 1.0704875 1.070487 v -0.62675 -0.62675 h 2.1430808 2.143081 v 0.62675 0.62675 h 1.070487 1.070487 l 0.01116,0.616641 0.01116,0.616641 0.280694,0.02774 c 0.908081,0.08973 1.700375,0.738819 2.014441,1.650337 l 0.09056,0.26283 0.01076,8.380255 0.01076,8.380254 h 0.626096 0.626095 v 0.888726 0.888726 l 0.7986,0.01096 0.798601,0.01096 0.0082,0.960343 0.0082,0.960343 H 20.004275 18.42917 v -0.970452 -0.970452 h -1.43546 -1.435459 v -1.152411 -1.152411 h -0.424209 -0.424209 l -0.01047,2.092536 -0.01047,2.092536 -1.08165,0.01077 -1.081649,0.01077 v -2.103306 -2.103305 h -0.525661 -0.525661 v 2.103305 2.103306 l -1.08165,-0.01077 -1.0816489,-0.01077 -0.010473,-2.092536 -0.010473,-2.092536 H 8.8658849 8.4416762 v 1.152411 1.152411 H 7.0062165 5.5707567 v 0.970452 0.970452 H 3.9956514 2.4205461 Z M 10.82737,25.341148 c 0.0158,-0.23176 0.03735,-0.309004 0.09871,-0.353811 0.115072,-0.08404 2.073205,-0.08404 2.188277,0 0.06136,0.04481 0.08291,0.122051 0.09871,0.353811 l 0.02022,0.296488 0.602558,0.01122 0.602557,0.01122 -0.02539,-0.357651 c -0.04176,-0.588281 -0.238172,-1.077936 -0.521921,-1.301133 -0.05945,-0.04676 -0.195383,-0.125322 -0.302077,-0.174578 -0.188224,-0.08689 -0.234869,-0.08955 -1.569677,-0.08955 h -1.375689 l -0.261948,0.12977 c -0.298081,0.147669 -0.4563327,0.323463 -0.5906901,0.656167 -0.1371612,0.339646 -0.2294693,1.028067 -0.1486829,1.108854 0.015411,0.01541 0.2838013,0.02299 0.596423,0.01685 l 0.568404,-0.01117 z M 9.7356117,20.461894 V 19.956451 H 8.9875552 8.2394988 v 0.505443 0.505444 h 0.7480564 0.7480565 z m 6.0653233,0 v -0.505443 h -0.748057 -0.748056 v 0.505443 0.505444 h 0.748056 0.748057 z" id="path6103" /></g></svg>
            </div>
        </div>

        <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
            <button onclick="attackEnemy()">Attack</button>
            <button onclick="exitFight()">Flee</button>
        </div>
    </div>

    <script>
        // !@! Database
        let database = [
  {"ElementType":"action","ElementKey":"n705xwmxq3mastshqy","Name":"","ParentKey":"1o6oungexyajmastshqy","Syntax":"","Logic":"game_title","Output":"","Tags":"key","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"1o6oungexyajmastshqy","Name":"","ParentKey":"global01","Syntax":"(title)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"fuqekpor9efmastshqy","Name":"","ParentKey":"9gsqqm4b4bamastshqy","Syntax":"","Logic":"[player]((stats))","Output":"Stats:","Tags":"list","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"9gsqqm4b4bamastshqy","Name":"","ParentKey":"global01","Syntax":"(stats)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"icnetxug0xmastshqy","Name":"","ParentKey":"96y6ujaq3wmastshqy","Syntax":"","Logic":"[player]((inventory))","Output":"Inventory:","Tags":"list","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"96y6ujaq3wmastshqy","Name":"","ParentKey":"global01","Syntax":"(inventory|inv)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"set","ElementKey":"gza8nmh5z3mastshqy","Name":"","ParentKey":"ec6qnm0p1mumastshqy","Syntax":"","Logic":"player_armed","Output":"","Tags":"arm","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"ec6qnm0p1mumastshqy","Name":"","ParentKey":"global01","Syntax":"(arm .*)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"global","ElementKey":"global01","Name":"","ParentKey":"root","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"frmbln8juimastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:3|5]","Tags":"stats_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"kbcw5sdymjdmastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:4|6]","Tags":"money_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"w6nv1y2thn8mastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|6]","Tags":"life_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"ava872eryyemastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|4]","Tags":"armor_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"b6wwxijbebimastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|5]","Tags":"strength_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"h0ddtedn6yqmastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|5]","Tags":"int_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"qq1wrmum7aqmastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|5]","Tags":"cunning_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"iz1pa2g8vrmastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[rand:<<[self]((money_dice))>>|9]","Tags":"gold_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"ginbvhevs4mastshqy","Name":"Life","ParentKey":"player","Syntax":"","Logic":"","Output":"[roll:(8)<<[self]((life_dice))>>d6]","Tags":"stats|life","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"dk93ep5h6eqmastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"[player]((life))","Tags":"maxlife","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"6gaoed3d79gmastshqy","Name":"Armor Rating","ParentKey":"player","Syntax":"","Logic":"","Output":"[roll:(6)<<[self]((armor_dice))>>d6+3]","Tags":"stats|!_armor","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},
  {"ElementType":"attribute","ElementKey":"r7utlcld52mastshqy","Name":"Strength","ParentKey":"player","Syntax":"","Logic":"","Output":"[roll:(6)<<[self]((strength_dice))>>d6]","Tags":"stats","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"5ydtq516o4dmastshqy","Name":"Intelligence","ParentKey":"player","Syntax":"","Logic":"","Output":"[roll:(6)<<[self]((int_dice))>>d6]","Tags":"stats","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"urp06qc413mastshqy","Name":"Cunning","ParentKey":"player","Syntax":"","Logic":"","Output":"[roll:(6)<<[self]((cunning_dice))>>d6]","Tags":"stats","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"67nt3rjmc3mmastshqy","Name":"Gold","ParentKey":"player","Syntax":"","Logic":"","Output":"[roll:<<[self]((gold_dice))>>d8]","Tags":"stats|gold","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"bctt4ifetkvmastshqy","Name":"Armed Weapon","ParentKey":"player","Syntax":"","Logic":"","Output":"long-sword_01","Tags":"!_armed|stats|name","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"experience","Name":"Experience","ParentKey":"player","Syntax":"","Logic":"","Output":"0","Tags":"experience|stats","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"q5w597to33cmastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"5","Tags":"heal_rounds","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"lvsfexbyhgmastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"0","Tags":"cur_heal_round","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"sgpyg4twn2pmastshqy","Name":"Quest","ParentKey":"player","Syntax":"","Logic":"","Output":"","Tags":"stats|quest","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"fra9zwhgez5mastshqy","Name":"","ParentKey":"vbhud4c71jmastshqy","Syntax":"","Logic":"","Output":"[player]","Tags":"target","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attack","ElementKey":"vbhud4c71jmastshqy","Name":"","ParentKey":"a92v43b66ymastshqy","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attackplayer","ElementKey":"a92v43b66ymastshqy","Name":"","ParentKey":"player","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"fh6tg9g1m0jmastshqy","Name":"Damage","ParentKey":"long-sword_01","Syntax":"","Logic":"[rand:4|12]","Output":"","Tags":"!_damage","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"i9ywkqgs3rnmastshqy","Name":"","ParentKey":"long-sword_01","Syntax":"","Logic":"","Output":"a Long Sword","Tags":"title","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"object","ElementKey":"long-sword_01","Name":"Long Sword","ParentKey":"player","Syntax":"\\b(?:your\\s+)?long\\s+sword\\b","Logic":"","Output":"","Tags":"inventory|!_weapon","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"player","ElementKey":"player","Name":"","ParentKey":"home","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":3},{"ElementType":"attribute","ElementKey":"vksnmaw34hrmastshqz","Name":"","ParentKey":"s95a0td4xwnmastshqy","Syntax":"","Logic":"","Output":"admin","Tags":"!_adminpass","Repeat":"","RepeatIndex":"0","Active":"true","Sort":4},{"ElementType":"attribute","ElementKey":"ncvfu8bgu8mastshqz","Name":"","ParentKey":"s95a0td4xwnmastshqy","Syntax":"","Logic":"","Output":"\nI don't understand what you are trying to do.","Tags":"!_error","Repeat":"","RepeatIndex":"0","Active":"true","Sort":4},{"ElementType":"attribute","ElementKey":"qkjst89omfmastshqz","Name":"","ParentKey":"s95a0td4xwnmastshqy","Syntax":"","Logic":"","Output":"false","Tags":"game_started","Repeat":"","RepeatIndex":"0","Active":"true","Sort":4},{"ElementType":"attribute","ElementKey":"f8rgu28uyjimastshqz","Name":"","ParentKey":"s95a0td4xwnmastshqy","Syntax":"","Logic":"","Output":"look","Tags":"!_defact","Repeat":"","RepeatIndex":"0","Active":"true","Sort":4},
  {"ElementType":"message","ElementKey":"70s72r9cyqxmastshqz","Name":"","ParentKey":"s95a0td4xwnmastshqy","Syntax":"","Logic":"","Output":"\nYou have died.","Tags":"!_die","Repeat":"","RepeatIndex":"0","Active":"true","Sort":4},{"ElementType":"message","ElementKey":"zw4d99shazmastshqz","Name":"","ParentKey":"s95a0td4xwnmastshqy","Syntax":"","Logic":"","Output":"\n\nWelcome to\n\n\n▓█████▄  ▄▄▄       ██▀███   ██ ▄█▀\n▒██▀ ██▌▒████▄    ▓██ ▒ ██▒ ██▄█▒\n░██   █▌▒██  ▀█▄  ▓██ ░▄█ ▒▓███▄░\n░▓█▄   ▌░██▄▄▄▄██ ▒██▀▀█▄  ▓██ █▄\n░▒████▓  ▓█   ▓██▒░██▓ ▒██▒▒██▒ █▄\n▒▒▓  ▒  ▒▒   ▓▒█░░ ▒▓ ░▒▓░▒ ▒▒ ▓▒\n░ ▒  ▒   ▒   ▒▒ ░  ░▒ ░ ▒░░ ░▒ ▒░\n░ ░  ░   ░   ▒     ░░   ░ ░ ░░ ░\n░          ░  ░   ░     ░  ░\n░\n█     █░ ▒█████   ██▀███   ██▓    ▓█████▄\n▓█░ █ ░█░▒██▒  ██▒▓██ ▒ ██▒▓██▒    ▒██▀ ██▌\n▒█░ █ ░█ ▒██░  ██▒▓██ ░▄█ ▒▒██░    ░██   █▌\n░█░ █ ░█ ▒██   ██░▒██▀▀█▄  ▒██░    ░▓█▄   ▌\n░░██▒██▓ ░ ████▓▒░░██▓ ▒██▒░██████▒░▒████▓\n░ ▓░▒ ▒  ░ ▒░▒░▒░ ░ ▒▓ ░▒▓░░ ▒░▓  ░ ▒▒▓  ▒\n▒ ░ ░    ░ ▒ ▒░   ░▒ ░ ▒░░ ░ ▒  ░ ░ ▒  ▒\n░   ░  ░ ░ ░ ▒    ░░   ░   ░ ░    ░ ░  ░\n░        ░ ░     ░         ░  ░   ░\n░\n\n\n","Tags":"!_start","Repeat":"","RepeatIndex":"0","Active":"true","Sort":4},{"ElementType":"game","ElementKey":"s95a0td4xwnmastshqy","Name":"Sample Game","ParentKey":"root","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":4},{"ElementType":"attribute","ElementKey":"s7jejua4evomastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"[rand:3|4]","Output":"","Tags":"stats_dice","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"ziga990gvdmastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|4]","Tags":"life_roll","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"j7erln4dk9mastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|5]","Tags":"armor_roll","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"xwawnliezwgmastshqz","Name":"Life","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"[rand:<<[self]((stats_dice))>>|4]","Tags":"stats|life","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"pkaozf8e5ymastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"[roll:(6)<<[self]((armor_roll))>>d4+3]","Tags":"stats|!_armor","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"fs7kertl5cmastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"rat_claws_01","Tags":"!_armed|name","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"c3dj47fom2imastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"\nYou have hit the rat.\n","Tags":"!_hitmsg","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"c0kh6rx3w7imastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"\nYou have attacked the rat, but missed.\n","Tags":"!_missmsg","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"c5e77v05g2amastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"\nYou have killed the rat.\n","Tags":"!_killmsg","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"cd5rdarchunmastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"\nThe rat has attacked you, but missed.\n","Tags":"!_missplayermsg","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"lgpv2pa702mastshqz","Name":"","ParentKey":"2ypadwegukymastshqz","Syntax":"","Logic":"","Output":"\n\nYou see a rat.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"look","ElementKey":"2ypadwegukymastshqz","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attack","ElementKey":"21egs04k12wmastshqz","Name":"","ParentKey":"zloskh444amastshqz","Syntax":"","Logic":"[self]","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"zloskh444amastshqz","Name":"","ParentKey":"npc_rat","Syntax":"(attack.*rat|!.*rat)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"mupm760igymastshqz","Name":"","ParentKey":"rat_claws_01","Syntax":"","Logic":"[rand:4|9]","Output":"","Tags":"!_damage","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"3t6sxnh1naymastshqz","Name":"","ParentKey":"rat_claws_01","Syntax":"","Logic":"","Output":"rat claws","Tags":"title","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"object","ElementKey":"rat_claws_01","Name":"","ParentKey":"npc_rat","Syntax":"","Logic":"","Output":"","Tags":"!_weapon","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},
  {"ElementType":"npc","ElementKey":"npc_rat","Name":"","ParentKey":"root","Syntax":"","Logic":"","Output":"","Tags":"enemy","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"1hsdb7rrjgemastshqz","Name":"","ParentKey":"fight_room","Syntax":"","Logic":"","Output":"\nYou step into the fighting arena!\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"ykbcio5nx2amastshqz","Name":"","ParentKey":"nwagnvcr19mastshqz","Syntax":"","Logic":"","Output":"\nYou look around.\nYou are in the fight test room.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"look","ElementKey":"nwagnvcr19mastshqz","Name":"","ParentKey":"fight_room","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"xjsj3f3b6fmastshqz","Name":"","ParentKey":"8nh6rs4vscemastshqz","Syntax":"","Logic":"","Output":"\n\nNavigation:\nHome\nCoin\nFight\nPutting\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"navigation","ElementKey":"8nh6rs4vscemastshqz","Name":"","ParentKey":"fight_room","Syntax":"","Logic":"","Output":"","Tags":"look|enter_message","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"zyj6esrztapmastshqz","Name":"","ParentKey":"u56u99c35ztmastshqz","Syntax":"","Logic":"home","Output":"You return to the testing home room.","Tags":"[player]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"u56u99c35ztmastshqz","Name":"","ParentKey":"fight_room","Syntax":"(home)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"kj2yjchgj3dmastshqz","Name":"","ParentKey":"khsmllvv51gmastshqz","Syntax":"","Logic":"look","Output":"","Tags":"type|room","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"khsmllvv51gmastshqz","Name":"","ParentKey":"fight_room","Syntax":"(look(?: around)?|l)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"room","ElementKey":"fight_room","Name":"Fight Room","ParentKey":"root","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"m146lulr6gkmastshqz","Name":"","ParentKey":"e25kxt3bf46mastshqz","Syntax":"","Logic":"","Output":"\n\nYou see a red button in the center of the room.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"rxfmoj9hanemastshqz","Name":"","ParentKey":"c6tyziwqcmomastshqz","Syntax":"","Logic":"","Output":"\n\nYou see a red button in the middle of the room.","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"look","ElementKey":"c6tyziwqcmomastshqz","Name":"","ParentKey":"e25kxt3bf46mastshqz","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"i3k9agffq0jmastshqz","Name":"","ParentKey":"w8d1667lw8mastshqz","Syntax":"","Logic":"","Output":"\n\nA rat appears!","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"w8d1667lw8mastshqz","Name":"","ParentKey":"1qni3q980oomastshqz","Syntax":"","Logic":"npc_rat","Output":"[room]","Tags":"spawn","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"1qni3q980oomastshqz","Name":"","ParentKey":"e25kxt3bf46mastshqz","Syntax":"(click.*button|press.*button|push.*button)","Logic":"","Output":"\n\nYou've pressed the button.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"0oxl43btfcyhmastshqz","Name":"","ParentKey":"tt620tun8tmastshqz","Syntax":"","Logic":"","Output":"\n\nNavigation:\nHome\nCoin\nFight\nPutting\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"navigation","ElementKey":"tt620tun8tmastshqz","Name":"","ParentKey":"e25kxt3bf46mastshqz","Syntax":"","Logic":"","Output":"","Tags":"look|enter_message","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"3oxg2y7v7vgmastshqz","Name":"","ParentKey":"zrnw8w2brwmastshqz","Syntax":"","Logic":"home","Output":"You return to the testing home room.","Tags":"[player]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},
  {"ElementType":"input","ElementKey":"zrnw8w2brwmastshqz","Name":"","ParentKey":"e25kxt3bf46mastshqz","Syntax":"(home)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"8wagm8tdad3mastshqz","Name":"","ParentKey":"34rr12i5r2zmastshqz","Syntax":"","Logic":"look","Output":"","Tags":"type|room","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"34rr12i5r2zmastshqz","Name":"","ParentKey":"e25kxt3bf46mastshqz","Syntax":"(look(?: around)?|l)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"object","ElementKey":"e25kxt3bf46mastshqz","Name":"","ParentKey":"fight_room","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"set","ElementKey":"6n0je28ouwamastshr0","Name":"","ParentKey":"v77ktyk1b5mastshr0","Syntax":"","Logic":"[game]((game_started))","Output":"true","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"v77ktyk1b5mastshr0","Name":"","ParentKey":"home","Syntax":"","Logic":"","Output":"\nWelcome to the WorldWeaver Testing Game.\n\nTo enter a test room simply enter its name.\n(No need to say \"go to\").\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"s5c8g7why3mastshr0","Name":"","ParentKey":"z75kfxqv5umastshr0","Syntax":"","Logic":"","Output":"\nYou are in the testing room.\n\nTo enter a test room simply enter its name.\n(No need to say \"go to\").\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"look","ElementKey":"z75kfxqv5umastshr0","Name":"","ParentKey":"home","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"02uh2r7lu7ommastshr0","Name":"","ParentKey":"jqk3silmt1mastshr0","Syntax":"","Logic":"","Output":"\n\nNavigation:\nHome\nCoin\nFight\nPutting\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"navigation","ElementKey":"jqk3silmt1mastshr0","Name":"","ParentKey":"home","Syntax":"","Logic":"","Output":"","Tags":"look|enter_message","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"w93q0ib6uvamastshr0","Name":"","ParentKey":"4arpt3c21ztmastshr0","Syntax":"","Logic":"look","Output":"","Tags":"type|room","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"4arpt3c21ztmastshr0","Name":"","ParentKey":"home","Syntax":"(look(?: around)?|l)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"9bjn02qfktmmastshr0","Name":"","ParentKey":"14gk4zjxt4gmastshr0","Syntax":"","Logic":"coin_room","Output":"\nYou have decided to test receiving money.\n","Tags":"[player]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"14gk4zjxt4gmastshr0","Name":"","ParentKey":"home","Syntax":"(coin)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"lkhuwxwhppomastshr0","Name":"","ParentKey":"nzu2a1ojrwmastshr0","Syntax":"","Logic":"fight_room","Output":"\nYou have decided to test the fight room.\n","Tags":"[player]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"nzu2a1ojrwmastshr0","Name":"","ParentKey":"home","Syntax":"(fight)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"sbpnx5auh2mastshr0","Name":"","ParentKey":"p707p3doqfhmastshr0","Syntax":"","Logic":"taking_room","Output":"\nYou have decided to test the putting room.\n","Tags":"[player]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"p707p3doqfhmastshr0","Name":"","ParentKey":"home","Syntax":"(putting)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"room","ElementKey":"home","Name":"Testing Home Room","ParentKey":"root","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"hnl5chj7cm9mastshr0","Name":"","ParentKey":"coin_room","Syntax":"","Logic":"","Output":"\nYou are in an empty room.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},
  {"ElementType":"message","ElementKey":"y5y2gizm5fmastshr0","Name":"","ParentKey":"i8bzfektviqmastshr0","Syntax":"","Logic":"","Output":"\nYou look around.\nYou are in a small room.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"look","ElementKey":"i8bzfektviqmastshr0","Name":"","ParentKey":"coin_room","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"otu7vsddh3rmastshr0","Name":"","ParentKey":"x5wh2vap7hhmastshr0","Syntax":"","Logic":"","Output":"\n\nNavigation:\nHome\nCoin\nFight\nPutting\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"navigation","ElementKey":"x5wh2vap7hhmastshr0","Name":"","ParentKey":"coin_room","Syntax":"","Logic":"","Output":"","Tags":"look|enter_message","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"n5me8e6zz5nmastshr0","Name":"","ParentKey":"kek6aafagjtmastshr0","Syntax":"","Logic":"home","Output":"You return to the testing home room.","Tags":"[player]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"kek6aafagjtmastshr0","Name":"","ParentKey":"coin_room","Syntax":"(home)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"a5yep0svjbmmastshr0","Name":"","ParentKey":"80pumy03eipmastshr0","Syntax":"","Logic":"look","Output":"","Tags":"type|room","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"80pumy03eipmastshr0","Name":"","ParentKey":"coin_room","Syntax":"(look(?: around)?|l)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"room","ElementKey":"coin_room","Name":"Coin Room","ParentKey":"root","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"attribute","ElementKey":"prz8hkuz9zcmastshr0","Name":"","ParentKey":"tkm0p7rro5nmastshr0","Syntax":"","Logic":"","Output":"false","Tags":"moved","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"48tloifotnkmastshr0","Name":"","ParentKey":"tkm0p7rro5nmastshr0","Syntax":"","Logic":"","Output":"\nYou see a gold coin.","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"3ii7aklu6pvmastshr0","Name":"","ParentKey":"w4tw8dlxp3rmastshr0","Syntax":"","Logic":"","Output":"\nYou see a gold coin.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"logic","ElementKey":"aje5wuzp2phmastshr0","Name":"","ParentKey":"w4tw8dlxp3rmastshr0","Syntax":"","Logic":"?[self]((moved)) = 'false'","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"look","ElementKey":"w4tw8dlxp3rmastshr0","Name":"","ParentKey":"tkm0p7rro5nmastshr0","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"a16asvw9jqmastshr0","Name":"","ParentKey":"d5lvhx7g4ymastshr0","Syntax":"","Logic":"!_limbo","Output":"\nYou take the gold coin.\n","Tags":"[self]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"set","ElementKey":"n85ls636rjdmastshr0","Name":"","ParentKey":"d5lvhx7g4ymastshr0","Syntax":"","Logic":"[player]((gold))","Output":"+=1","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"d5lvhx7g4ymastshr0","Name":"","ParentKey":"tkm0p7rro5nmastshr0","Syntax":"^(take|pick up)\\s+(the\\s+)?coin","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"object","ElementKey":"tkm0p7rro5nmastshr0","Name":"Gold Coin","ParentKey":"coin_room","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"m2k1lrw4lvmastshr0","Name":"","ParentKey":"taking_room","Syntax":"","Logic":"","Output":"\nYou are in the taking and putting room.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"49uif3t7pyxmastshr0","Name":"","ParentKey":"6b6rkm19svcmastshr0","Syntax":"","Logic":"","Output":"\nYou look around...\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},
  {"ElementType":"look","ElementKey":"6b6rkm19svcmastshr0","Name":"","ParentKey":"taking_room","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"z1c7gsze7ymastshr0","Name":"","ParentKey":"b534s0y6eqfmastshr0","Syntax":"","Logic":"","Output":"\n\nNavigation:\nHome\nCoin\nFight\nPutting\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"navigation","ElementKey":"b534s0y6eqfmastshr0","Name":"","ParentKey":"taking_room","Syntax":"","Logic":"","Output":"","Tags":"look|enter_message","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"jxvng8z40dmastshr0","Name":"","ParentKey":"zg25wsvsvmrmastshr0","Syntax":"","Logic":"home","Output":"You return to the testing home room.","Tags":"[player]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"zg25wsvsvmrmastshr0","Name":"","ParentKey":"taking_room","Syntax":"(home)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"4ygh8i4hcgtmastshr0","Name":"","ParentKey":"akwx1f4mdljmastshr0","Syntax":"","Logic":"look","Output":"","Tags":"type|room","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"akwx1f4mdljmastshr0","Name":"","ParentKey":"taking_room","Syntax":"(look(?: around)?|l)","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"room","ElementKey":"taking_room","Name":"The Taking and Putting Room","ParentKey":"root","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"peoulfhafgqmastshr0","Name":"","ParentKey":"9e0p4j6w9cmastshr0","Syntax":"","Logic":"","Output":"\nYou see a box.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"message","ElementKey":"jr8h568hal8mastshr0","Name":"","ParentKey":"pijf3vg1o3rmastshr0","Syntax":"","Logic":"","Output":"\n\nYou see a box.","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"logic","ElementKey":"08p6ylkhy6iimastshr0","Name":"","ParentKey":"pijf3vg1o3rmastshr0","Syntax":"","Logic":"?[self]parent = [room]","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"look","ElementKey":"pijf3vg1o3rmastshr0","Name":"","ParentKey":"9e0p4j6w9cmastshr0","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"r9815fwrhdmastshr1","Name":"","ParentKey":"lggoqy682qgmastshr1","Syntax":"","Logic":"look","Output":"\nYou examine the box.\n","Tags":"type|children","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"examine_box","ElementKey":"lggoqy682qgmastshr1","Name":"","ParentKey":"9e0p4j6w9cmastshr0","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"move","ElementKey":"dvvwd3woekimastshr1","Name":"","ParentKey":"yn9x44y5wbjmastshr1","Syntax":"","Logic":"[self]","Output":"\nYou put the [target] in the box.\n","Tags":"[syntax]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"yn9x44y5wbjmastshr1","Name":"","ParentKey":"9e0p4j6w9cmastshr0","Syntax":"put.*in.*box","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"action","ElementKey":"oqd22x65pwgmastshr1","Name":"","ParentKey":"v4njck85m3cmastshr1","Syntax":"","Logic":"examine_box","Output":"","Tags":"type|self","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"input","ElementKey":"v4njck85m3cmastshr1","Name":"","ParentKey":"9e0p4j6w9cmastshr0","Syntax":"examine.*box|x.*box","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"object","ElementKey":"9e0p4j6w9cmastshr0","Name":"Box","ParentKey":"taking_room","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":1},{"ElementType":"enter_message","ElementKey":"f2tm4u1ucnqmastshr1","Name":"","ParentKey":"n6wxsb6rpnmastshr1","Syntax":"","Logic":"","Output":"\nYou see a key.\n","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2},
  {"ElementType":"message","ElementKey":"aplmbh6zmqcmastshr1","Name":"","ParentKey":"a2o9fqvjs98mastshr1","Syntax":"","Logic":"","Output":"\n\nYou see a key.","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2},{"ElementType":"logic","ElementKey":"m8paiyfyzfmastshr1","Name":"","ParentKey":"a2o9fqvjs98mastshr1","Syntax":"","Logic":"?[self]parent = [room]","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2},{"ElementType":"look","ElementKey":"a2o9fqvjs98mastshr1","Name":"","ParentKey":"n6wxsb6rpnmastshr1","Syntax":"","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2},{"ElementType":"move","ElementKey":"tzn9avmo79bmastshr1","Name":"","ParentKey":"j8f77ckfjxjmastshr1","Syntax":"","Logic":"[player]","Output":"\nYou take the key.","Tags":"[self]","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2},{"ElementType":"set","ElementKey":"hiufcltg98nmastshr1","Name":"","ParentKey":"j8f77ckfjxjmastshr1","Syntax":"","Logic":"[self]tags","Output":"+inventory","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2},{"ElementType":"input","ElementKey":"j8f77ckfjxjmastshr1","Name":"","ParentKey":"n6wxsb6rpnmastshr1","Syntax":"^(take|pick up)\\s+(the\\s+)?key","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2},{"ElementType":"object","ElementKey":"n6wxsb6rpnmastshr1","Name":"Key","ParentKey":"taking_room","Syntax":".*key.*","Logic":"","Output":"","Tags":"","Repeat":"","RepeatIndex":"0","Active":"true","Sort":2}
];

        // Parsers
            const actionParsers = ["attribute", "logic", "input", "action", "set", "move", "message"];
            const attackParsers = ["attribute", "logic", "action"];
            const fleeParsers = ["attribute", "logic", "action"]; 
            const attributeParsers = ["attribute"];
            const enterMessageParsers = ["logic", "message", "action", "attack"];
            const gameParsers = ["set_field", "set_game_state", "message", "action", "room", "input"];
            const globalParsers = ["logic", "input", "action", "message"];
            const inputParsers = ["logic", "preset", "set", "action", "attack", "flee", "message", "move"];
            const logicParsers = ["logic", "action", "set", "message"];
            const messageParsers = ["logic", "action", "message", "set"];
            const navigationParsers = ["message"];
            const generalParsers = ["logic", "enter_message", "message", "action", "set", "npc"];
            const moveParsers = ["logic", "set", "message"];
            const npcParsers = ["link", "travel", "enter_message", "logic", "input", "action", "attack", "set", "message", "dev_note"];
            const objectParsers = ["link", "travel", "enter_message", "object", "logic", "action", "set", "move", "message", "input", "dev_note"];
            const playerParsers = ["link", "message", "attack", "flee", "input", "dev_note"];
            const roomParsers = ["link", "logic", "action", "enter_message", "set", "object", "message", "input", "npc", "move", "navigation", "dev_note"];
            const roundParsers = ["link", "logic", "action", "set"];
            const rulesetParsers = ["rule"];
            const ruleParsers = ["rule"];
            const setParsers = ["logic", "set"];
            const testParsers = ["teststep"];
            const travelParsers = ["enter_message", "logic", "move", "message"];
            const weaponParsers = ["dev_note"];

        // Config Items
            const selfTypes = ["object", "room", "player", "npc", "game", "global"];
            const canContainCustomElems = ["npc", "object", "room"];
            const operands = [" != ", " >= ", "<= ", " !~~ ", " ~~ ", " >< ", " <> ", " = ", " > ", " < "];
            // Special Tags
                const adminTag = "!_adminpass";
                const defActTag = "!_defact";
                const errorTag = "!_error";
                const dieTag = "!_die";
                const startTag = "!_start";
                const armedTag = "!_armed";
                const armorTag = "!_armor";
                const damageTag = "!_damage";
                const weaponTag = "!_weapon";
                const hitMsgTag = "!_hitmsg";
                const missMsgTag = "!_missmsg";
                const missPlayerMsgTag = "!_missplayermsg";
                const killMsgTag = "!_killmsg";
                const limboValue = "!_limbo";
                const enterTag = "!_enter";
                const leaveTag = "!_leave";

        // Classes
            let gameOutput = {
                "MatchMade": "false",
                "InputMatchMade": "false",
                "ContinueParsing": "true",
                "EnterMsgDone": "false",
                "Output": ""
            };
            let userInput = {
                "Input": ""
            };

        // Global Vars
            let gameStarted = false;
            const output = document.getElementById("output");
            const input = document.getElementById("input");
            const gameInterface = document.getElementById("game-interface");
            const elementTypes = [
                "action", "attack", "attribute", "dev_note", "enter_message", "global", "injection",
                "input", "link", "logic", "message", "move", "navigation", "nothing", "npc", "object",
                "room", "set", "travel"
            ];
            let macroRunning = false;
            let currentEnemy = "";
            let playerDead = false;


        function logMessage(message) {
            output.innerHTML = message + "<br>";
            output.scrollTop = output.scrollHeight;
        }

        function saveFile() {
            let elemLimit = 20; // Number of elements per line
            let htmlDoc = document.documentElement.cloneNode(true);
            htmlDoc.querySelector("#output").innerHTML = ""; // Clear output before saving
            let fileName = "worldweaver";

            let fileNameElem = database.find(item => item.Tags === "!_filename") ?? null;
            if (fileNameElem)
            {
                fileName = fileNameElem.Output;
            }

            // Make sure the latest database is stored
            let latestDatabase = JSON.parse(JSON.stringify(database)); // Deep clone to ensure correctness

            // Build compact JSON with newlines every elemLimit items
            let lines = [];
            for (let i = 0; i < latestDatabase.length; i += elemLimit) {
                let chunk = latestDatabase.slice(i, i + elemLimit);
                lines.push(JSON.stringify(chunk).slice(1, -1)); // Strip [ and ]
            }
            let formattedDatabase = `[\n  ${lines.join(",\n  ")}\n]`;

            // Ensure correct replacement of the old database
            let htmlContent = "<!DOCTYPE html>" + htmlDoc.outerHTML;
            htmlContent = htmlContent.replace(/let database = \[([\s\S]*?)\];/, `let database = ${formattedDatabase};`);

            let blob = new Blob([htmlContent], { type: "text/html" });
            let a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${fileName}.html`;
            a.click();
        }

        // Events
        input.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                let command = input.value.trim();
                if (command) {
                    processInput(command);
                    showOutput();
                }
                input.value = "";
            }
        });

        function showOutput()
        {
            if (gameOutput.MatchMade && gameOutput.Output)
            {
                output.innerHTML += gameOutput.Output + "<br>";
                output.scrollTop = output.scrollHeight;
            }
        }


        function showGameStartScreen()
        {
            let playerElem = getPlayer();

            if (playerElem.Name === "")
            {
                output.innerHTML = "Set player name:";
                return;
            }

            if (!gameStarted)
            {
                let startScreen = "Welcome to WorldWeaver...";
                let startMsg = database.find(item => item.ParentKey === getGameKey() && tagsContain(item.Tags, startTag)) ?? null;
                if (startMsg !== null)
                {
                    output.innerHTML = startMsg.Output;
                }
                else
                {
                    output.innerHTML = "";
                }
                gameStarted = true;
            }
            else
            {
                output.innerHTML = "";
            }
        }


        window.onload = function() {
            gameInterface.style.display = "flex";

            

            fixFolders();
            doOnStartInjection();
            doOnStartRandomFixes();

            showGameStartScreen();

            // Ensure the database is not overwritten if it was injected from a saved file
            if (!Array.isArray(database) || database.length === 0) {
                database = [];
            }

            input.focus();
        };



        function fixFolders() {
            const folders = database.filter(item => item.ElementType === "folder");

            for (let folder of folders)
            {
                let children = getChildren(folder, true);
                for (let child of children)
                {
                    let parent = getElementByKey(child.ParentKey);
                    while (parent.ElementType === "folder" && parent.ParentKey !== null)
                    {
                        parent = getElementByKey(parent.ParentKey);
                    }
                    if (parent)
                    {
                        child.ParentKey = parent.ElementKey;
                    }
                    else
                    {
                        child.ParentKey = null;
                    }
                }
            }
        }

        function doOnStartInjection()
        {
            const injElems = database.filter(item => item.ElementType === "injection");

            for (let inj of injElems)
            {
                const parentElem = getParent(inj);
                let injElem = getElementByKey(inj.Logic);
                if (injElem === null)
                {
                    continue;
                }

                spawnElement(injElem, parentElem);
            }

            // Remove injection elements
            for (let inj of injElems)
            {
                deleteSingleElement(inj.ElementKey);
            }
        }

        function doOnStartRandomFixes()
        {
let randElems = database
    .filter(item =>
        typeof item.Output === 'string' &&
        (item.Output.startsWith("[rand:") || item.Output.startsWith("[roll:"))
    )
    .sort((a, b) => {
        const getSortRank = (item) => {
            const output = item.Output;
            const hasTags = output.includes("<<") && output.includes(">>");
            if (!hasTags) return 0;
            if (output.startsWith("[rand:")) return 1;
            if (output.startsWith("[roll:")) return 2;
            return 3; // fallback rank (optional)
        };

        return getSortRank(a) - getSortRank(b);
    });

            for (let rnd of randElems)
            {
                if (rnd.Output.startsWith("[rand:"))
                {
                    rnd.Output = getRandValue(rnd, rnd.Output);
                }
                else
                {
                    rnd.Output = getRollDiceValue(rnd, rnd.Output);
                }
            }
        }

        function doRandomRoll(rndElement, rndString)
        {
            if (rndString.startsWith("[rand:"))
            {
                return getRandValue(rndElement, rndString);
            }
            else
            {
                return getRollDiceValue(rndElement, rndString);
            }
        }

        function getRandValue(rndElement, rndString) {
            let range = rndString.replace("[rand:", "").replace(/](?!.*])/ , "").split("|");
            let rndVal = 0;
            let selElems = null;
            if (range.length === 2)
            {
                if (range[0].startsWith("<<"))
                {
                    selElems = getTargets(rndElement, range[0])?.[0] ?? null;
                    if (selElems === null)
                    {
                        range[0] = 0;
                    }
                    else
                    {
                        range[0] = selElems.Output;
                    }
                }
                if (range[1].startsWith("<<"))
                {
                    selElems = getTargets(rndElement, range[1])?.[0] ?? null;
                    if (selElems === null)
                    {
                        range[1] = 0;
                    }
                    else
                    {
                        range[1] = selElems.Output;
                    }
                }

                rndVal = getRandomByRange(range[0], range[1]);
                return rndVal;
            }
        }

        function getRandomByRange(min, max)
        {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getRollDiceValue(rndElement, rndString)
        {
            let roll = rndString.replace("[roll:", "").replace(/](?!.*])/ , "");
            let rndVal = -1;
            let rollVals = [];
            let totalDice = 0;
            let modValue = 0;
            let totalNumOfDice = 0;

            roll = roll.replace(/<<([^<>]+)>>/g, (match, rndString) => {
                return getTargets(rndElement, rndString)?.[0]?.Output ?? "";
            });

            if (roll.includes("+") || roll.includes("-"))
            {
                let delimiter = "+";
                if (roll.includes("-"))
                {
                    delimiter = "-";
                }
                modValue = processModifier(rndElement, delimiter, roll);
                let arr = roll.split(delimiter);
                if (arr.Length === 2)
                {
                    roll = arr[0].trim();
                }
            }

            if (roll.includes("(") && roll.includes(")"))
            {
                let arr = roll.split(")");
                if (arr.length == 2)
                {
                    roll = arr[1].trim();
                    arr[0] = arr[0].replace("(", "");
                    try
                    {
                        totalNumOfDice = Number(arr[0]);
                    }
                    catch (Exception)
                    {
                        totalNumOfDice = 0;
                    }
                }
            }

            let diceSpec = roll.split('d');
            try
            {
                if (diceSpec.length == 2)
                {
                    let numOfDice = Number(diceSpec[0].trim());
                    if (diceSpec[1].includes("+") || diceSpec[1].includes("-"))
                    {
                        let sidesArr = diceSpec[1].split("+");
                        if (sidesArr.length !== 2)
                        {
                            sidesArr = diceSpec[1].split("-");
                            diceSpec[1] = sidesArr[0];
                        }
                        else
                        {
                            diceSpec[1] = sidesArr[0];
                        }
                    }
                    let sides = Number(diceSpec[1].trim());
                    let total = 0;
                    let rollNum = numOfDice;
                    if (totalNumOfDice > numOfDice)
                    {
                        rollNum = totalNumOfDice;
                    }

                    for (let rolls = 0; rolls <= rollNum - 1; rolls++)
                    {
                        let rollVal = getRandomByRange(1, sides + 1);
                        rollVals.push(rollVal);
                    }

                    if (totalNumOfDice > numOfDice)
                    {
                        const sorted = rollVals.sort((a, b) => b - a);
                        let taken = sorted.slice(0, numOfDice);
                        total = taken.reduce((acc, curr) => acc + curr, 0);
                    }
                    else {
                        total = rollVals.reduce((acc, curr) => acc + curr, 0);
                    }

                    rndVal = total;

                    total = total + modValue;

                    return total;
                }
            }
            catch (Exception)
            {
                return rndVal;
            }
        }


        // Fighting
        function showFightInterface() {
            let msg = document.getElementById("fight-message");
            let player = getPlayer();
            let enemy = currentEnemy;
            let lifeStat = getChildrenByTag(player, "life")?.[0]?.Output || "0";
            let enemyLifeStat = getChildrenByTag(enemy, "life")?.[0]?.Output || "-1";
            document.getElementById("player-life").textContent = lifeStat;
            if (enemyLifeStat < 0)
            {
                return;
            }
            else
            {
                document.getElementById("enemy-life").textContent = enemyLifeStat;
            }

            msg.innerHTML = "";
            gameInterface.style.display = "none";
            document.getElementById("fight-interface").style.display = "flex";
        }

        function exitFight() {
            document.getElementById("fight-interface").style.display = "none";
            gameInterface.style.display = "flex";
            doDefaultRoomAction();
            input.focus();
        }

        function attackEnemy() {
            let msg = document.getElementById("fight-message");
            let enemyLifeEl = document.getElementById("enemy-life");
            let currentLife = parseInt(enemyLifeEl.textContent);
            const playerWeapon = getArmedWeapon(getPlayer());
            const attackRoll = getRollDiceValue(getPlayer(), "[roll:1d20]");
            const enemyArmorRating = getArmorRating(currentEnemy);

            const missMsg = getChildMessageByTag(currentEnemy, missMsgTag, "You have missed.");
            const hitMsg = getChildMessageByTag(currentEnemy, hitMsgTag, "You hit your enemy.");
            const killMsg = getChildMessageByTag(currentEnemy, killMsgTag, "You have killed your enemy.");

            if (attackRoll <= enemyArmorRating)
            {
                msg.innerHTML = missMsg;
                setTimeout(() => {
                    attackPlayer();
                }, 2000); // 1 second delay
                return;
            }

            const damage = getDamageValue(playerWeapon);
            currentLife -= damage;

            if (currentLife <= 0) {
                enemyLifeEl.textContent = "0";
                alert(killMsg);

                let enemy = getElementByKey(currentEnemy.ElementKey);
                enemy.ParentKey = "limbo";

                exitFight();
            } else {
                enemyLifeEl.textContent = currentLife.toString();

                msg.innerHTML = hitMsg;
                setTimeout(() => {
                    attackPlayer();
                }, 2000); // 1 second delay
            }
        }

        function attackPlayer() {
            let msg = document.getElementById("fight-message");
            let playerLifeEl = document.getElementById("player-life");
            let currentLife = parseInt(playerLifeEl.textContent);
            const enemyWeapon = getArmedWeapon(currentEnemy);
            const attackRoll = getRollDiceValue(getPlayer(), "[roll:1d20]");
            const playerArmorRating = getArmorRating(getPlayer());
            const player = getPlayer();

            const hitMsg = getChildMessageByTag(player, hitMsgTag, "You hit your enemy.");
            const missMsg = getChildMessageByTag(currentEnemy, missPlayerMsgTag, "The attack on you has failed.");
            const dieMsg = getChildMessageByTag(player, dieTag, "x_x");

            if (attackRoll <= playerArmorRating)
            {
                msg.innerHTML = missMsg;
                return;
            }

            msg.innerHTML = hitMsg;

            const damage = getDamageValue(enemyWeapon);
            currentLife -= damage;
            let lifeStat = getChildByTag(player, "life");
            lifeStat.Output = currentLife;

            if (currentLife <= 0) {
                playerLifeEl.textContent = "0";
                playerDead = true;
                alert(dieMsg);

                exitFight();
            } else {
                playerLifeEl.textContent = currentLife.toString();
            }
        }


        // Helper Methods
            function getGameKey()
            {
                const gameElem = database.find(item => item.ElementType === "game");
                return gameElem.ElementKey;
            }
            function getElement(referenceString, currentElement)
            {
                if (referenceString === "[room]")
                {
                    return getCurrentRoom();
                }
                if (referenceString === "[player]")
                {
                    return getPlayer();
                }
                if (referenceString === "[self]")
                {
                    return getSelf(currentElement);
                }
                if (referenceString === "[syntax]")
                {
                    let elem = null;
                    elem = getChildrenBySyntax(getPlayer(), userInput.Input);
                    if (elem !== null)
                    {
                        return elem;
                    }
                    elem = getChildrenBySyntax(getCurrentRoom(), userInput.Input);
                    if (elem !== null)
                    {
                        return elem;
                    }
                    elem = getChildrenBySyntax(getSelf(currentElement), userInput.Input);
                    if (elem !== null)
                    {
                        return elem;
                    }
                }

                return getElementByKey(referenceString);
            }
            function getChildrenBySyntax(parentElement, syntax)
            {
                const children = getChildren(parentElement, false);
                for (let child of children)
                {
                    if (regexCheck(child.Syntax, syntax))
                    {
                        return child;
                    }
                }

                return null;
            }
            function getElementByKey(elementKey)
            {
                let foundElem = database.find(item => item.ElementKey === elementKey) ?? null;
                return foundElem;
            }
            function getElementsByType(elementType)
            {
                return database.filter(item => item.ElementType === elementType).orderBy(e => parseInt(e.Sort));
            }
            function getElementsByTag(tag)
            {
                return database.filter(item => tagsContain(item.Tags, tag) === true);
            }
            function getSelf(currentElement)
            {
                let parentElem = getElementByKey(currentElement.ParentKey);

                if (currentElement.ParentKey === null)
                {
                    return null;
                }

                if (selfTypes.includes(parentElem.ElementType))
                {
                    return parentElem;
                }
                else
                {
                    getSelf(parentElem);
                }
            }
            function getParent(currentElement)
            {
                if (currentElement.ParentKey === null)
                {
                    return null;
                }
                let parentElem = database.find(item => item.ElementKey === currentElement.ParentKey) ?? null;
                return parentElem;
            }
            function getChildrenByTag(parentElement, tag)
            {
                let children = getChildren(parentElement, true);
                let foundChildren = [];
                for (const child of children)
                {
                    if (tagsContain(child.Tags, tag))
                    {
                        foundChildren.push(child);
                    }
                }
                return foundChildren;
            }
            function getChildrenByType(parentElement, type)
            {
                const children = database.filter(item => item.ParentKey === parentElement.ElementKey && item.ElementType == type);
                return children;
            }
            function getChildByTag(parentElement, tag)
            {
                let children = getChildren(parentElement, true);
                return children.filter(item => tagsContain(item.Tags, tag)).orderBy(e => parseInt(e.Sort))?.[0] ?? null;
            }
            function getChildMessageByTag(parentElement, tag, defaultMessage)
            {
                let children = getChildren(parentElement, true);
                return children.filter(item => tagsContain(item.Tags, tag)).orderBy(e => parseInt(e.Sort))?.[0]?.Output ?? defaultMessage;
            }
            function getChildren(parentElement, includeAttributes)
            {
                if (includeAttributes)
                {
                    return database.filter(item => item.ParentKey === parentElement.ElementKey).orderBy(e => parseInt(e.Sort));
                }
                else
                {
                    return database.filter(item => item.ParentKey === parentElement.ElementKey && item.ElementType !== "attribute").orderBy(e => parseInt(e.Sort));
                }
            }
            function getChildObjects(parentElement)
            {
                return database.filter(item => item.ParentKey === parentElement.ElementKey && item.ElementType === "object").orderBy(e => parseInt(e.Sort));
            }
            function getSelf(currentElement)
            {
                let parentElem = getParent(currentElement);
                if (parentElem === null)
                {
                    return currentElement;
                }
                if (selfTypes.includes(parentElem.ElementType))
                {
                    return parentElem;
                }
                else
                {
                    return getSelf(parentElem);
                }
            }
            function getCurrentRoom()
            {
                let playerElem = getPlayer();
                let roomElem = getElementByKey(playerElem.ParentKey);
                return roomElem;
            }
            function getPlayer()
            {
                return getElementsByType("player")[0];
            }
            function setPlayerArmed(elementKey)
            {
                let armedAttrib = database.find(item => item.ParentKey === getPlayer().ElementKey && tagsContain(item.Tags, armedTag)) ?? null;
                if (armedAttrib === null)
                {
                    return;
                }
                armedAttrib.Output = elementKey;
            }
            function setDefaultWeapon(droppingElement)
            {
                let weapons = database.find(item => item.ParentKey === getPlayer().ElementKey &&
                                            tagsContain(item.Tags, weaponTag) &&
                                            item.ElementKey !== droppingElement.ElementKey) ?? null;
                if (weapons === null)
                {
                    setPlayerArmed("");
                    return;
                }

                setPlayerArmed(weapons.ElementKey);
            }
            function getPlayerInventory()
            {
                return database.filter(item => item.ParentKey === getPlayer().ElementKey && tagsContain(item.Tags, "inventory"));
            }

            function getArmedWeapon(parentElement)
            {
                let armedAttrib = getChildrenByTag(parentElement, armedTag)?.[0] ?? null;
                if (armedAttrib === null)
                {
                    return;
                }

                if (armedAttrib !== null)
                {
                    weaponKey = armedAttrib.Output;
                }
                if (weaponKey === "")
                {
                    return null;
                }

                return getElementByKey(weaponKey);
            }

            function getArmorRating(parentElement)
            {
                let armorAttrib = getChildrenByTag(parentElement, armorTag);
                if (armorAttrib === null ||
                    armorAttrib.length !== 1)
                {
                    return 7;
                }

                return armorAttrib[0].Output;
            }

            function getDamageValue(armedWeapon)
            {
                if (armedWeapon === null)
                {
                    return 1;
                }
                let damageAttrib = getChildrenByTag(armedWeapon, damageTag)?.[0] ?? null;
                if (damageAttrib === null)
                {
                    return 1;
                }
                let rndString = damageAttrib.Logic;
                return doRandomRoll(armedWeapon, rndString);
            }

            function horizLine(title)
            {
                let hr = "";

                for (let i = 0; i < title.length; i++)
                {
                    hr += "-";
                }

                return hr;
            }

            function outputMatch(message, doAppend)
            {
                if (message === "")
                {
                    return;
                }

                gameOutput.MatchMade = true;
                if (doAppend)
                {
                    gameOutput.Output += message;
                }
                else
                {
                    gameOutput.Output = message;
                }
            }
            function tagsContain(tags, tagString)
            {
                let taglist = tags.split("|");
                return taglist.includes(tagString);
            }
            function addTag(currentElement, tagString)
            {
                if (currentElement.Tags === undefined)
                {
                    return;
                }
                if (currentElement.Tags === "")
                {
                    currentElement.Tags = tagString;
                    return;
                }
                let taglist = currentElement.Tags.split("|");
                if (!taglist.includes(tagString))
                {
                    taglist.push(tagString);
                }
                currentElement.Tags = taglist.join("|");
            }
            function removeTag(currentElement, tagString)
            {
                let taglist = currentElement.Tags.split("|").filter(item => item !== tagString);
                currentElement.Tags = taglist.join("|");
            }
            function processModifier(currentElement, modifier, roll)
            {
                let arr = roll.split(modifier);
                var modifierVal = 0;

                if (arr.length != 2)
                {
                    return 0;
                }

                try{
                    modifierVal = Number(getTargets(currentElement, arr[1].trim())?.[0] ?? "");
                    if (modifier === "-")
                    {
                        modifierVal = -(modifierVal);
                    }
                }
                catch (Exception)
                {
                    return 0;
                }

                return modifierVal;
            }
            function getGuid()
            {
                return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
            }
            Array.prototype.orderBy = function(selector, desc = false) {
              return [...this].sort((a, b) => {
                a = selector(a);
                b = selector(b);
            
                if (a == b) return 0;
                return (desc ? a > b : a < b) ? -1 : 1;
              });
            };
            function deleteElement(elementKey)
            {
                // Find all children of the element
                let children = database.filter(el => el.ParentKey === elementKey);

                // Recursively delete each child first
                for (let child of children) {
                    deleteElement(child.ElementKey);
                }

                // Now remove the element itself
                let index = database.findIndex(el => el.ElementKey === elementKey);
                if (index !== -1) {
                    database.splice(index, 1);
                }
            }
            function deleteSingleElement(elementKey)
            {
                let index = database.findIndex(el => el.ElementKey === elementKey);
                if (index !== -1) {
                    database.splice(index, 1);
                }
            }
            function regexCheck(regexString, inputString)
            {
                if (regexString === "" || inputString === "")
                {
                    return false;
                }
                let pattern = new RegExp(regexString, 'i');
                if (pattern.test(inputString))
                {
                    return true;
                }
                return false;
            }
            function doDefaultRoomAction()
            {
                let defaultCmd = getElementsByTag(defActTag)?.[0] ?? null;
                if (defaultCmd === null)
                {
                    parseRoom(roomParsers, false);
                    return;
                }
                defaultCmd = defaultCmd.Output;
                userInput.Input = defaultCmd;
                processInput(defaultCmd);
            }
        // End Helper Methods



        // Process the Player's input.
        // This will call all the other parsers.
        function processInput(command)
        {
            if (playerDead === true)
            {
                exit;
            }
            userInput.Input = command;
            gameOutput.InputMatchMade = false;
            gameOutput.MatchMade = false;
            gameOutput.Output = "";
            gameOutput.ContinueParsing = true;
            gameOutput.EnterMsgDone = false;
            output.scrollTop = output.scrollHeight;
            let playerElem = getPlayer();

            if (playerElem.Name === "" &&
                userInput.Input != "save" &&
                userInput.Input != "help")
            {
                output.innerHTML = "";
                playerElem.Name = userInput.Input;
                showGameStartScreen();
                parseGame(gameParsers);
                parseRoom(roomParsers, true);
                parsePlayer(playerParsers);
                gameOutput.EnterMsgDone = true;
                return;
            }

            if (userInput.Input === "save")
            {
                saveFile();
                input.value = "";
                input.focus();
                return;
            }

            output.innerHTML = "";

            if (command === "help")
            {
                outputMatch("I am here to help you!", false);
                gameOutput.MatchMade = true;
                return;
            }

            if (gameStarted)
            {
                if (userInput.Input === "!fight")
                {
                    showFightInterface();
                }

                handleTravel();
                parseGame(gameParsers);
                parseGlobal(globalParsers);
                parseRoom(roomParsers, false);
                parsePlayer(playerParsers);
                gameOutput.EnterMsgDone = true;
            }
        }


        // Travel
        function getActiveTraveling()
        {
            return database.filter(item => item.ElementType === "travel" && item.Active === "true");
        }
        function getOtherFollowingTraveling()
        {
            return database.filter(item => item.ElementType === "travel" && item.Logic.startsWith("[follow|") && item.Logic !== "[follow|player]" && item.Active === "true");
        }
        function getPlayerFollowingTraveling()
        {
            return database.filter(item => item.ElementType === "travel" && item.Logic === "[follow|player]" && item.Active === "true");
        }
        function getAllTraveling()
        {
            return database.filter(item => item.ElementType === "travel");
        }
        function handleTravel()
        {
            const trvls = getActiveTraveling();

            for (const trv of trvls)
            {
                if (trv.Logic.startsWith("[path|"))
                {
                    handlePath(trv);
                }
            }
        }

        function handlePath(travelElement)
        {
            // TODO: Finish this
            return;
        }

        function followPlayer()
        {
            const trvls = getPlayerFollowingTraveling();

            for (const trv of trvls)
            {
                let selfElement = getSelf(trv);
                if (selfElement === null)
                {
                    return;
                }
                const enterMessage = getChildrenByTag(trv, enterTag)?.[0] ?? null;
                if (enterMessage === null)
                {
                    return;
                }
                selfElement.ParentKey = getCurrentRoom().ElementKey;
                // parseMessage(trv, enterMessage);
            }
        }


        // Run the parsers
        function parseGame(parsers)
        {
            let gameElem = getElementsByType("game")[0];

            for (let prsr of parsers)
            {
                for (let child of getChildren(gameElem, false))
                {
                    callParser(prsr, gameElem, child);
                }
            }
        }

        function parseAction(currentElement, parsers)
        {
            if (actionParsers.includes("logic") && !processLogic(currentElement))
            {
                return;
            }

            parseElement(currentElement, parsers);

            if (tagsContain(currentElement.Tags, "type") &&
                currentElement.Logic !== "")
            {
                if (tagsContain(currentElement.Tags, "room"))
                {
                    parseCustomElement(getCurrentRoom(), getCurrentRoom(), currentElement.Logic, false);
                }
                if (tagsContain(currentElement.Tags, "player"))
                {
                    parseCustomElement(getPlayer(), getPlayer(), currentElement.Logic, false);
                }
                if (tagsContain(currentElement.Tags, "self"))
                {
                    parseCustomElement(getSelf(currentElement), getSelf(currentElement), currentElement.Logic, false);
                }
                if (tagsContain(currentElement.Tags, "children"))
                {
                    gameOutput.Output = currentElement.Output;
                    let children = getChildObjects(getSelf(currentElement));

                    for (let child of children)
                    {
                        parseCustomElement(getSelf(currentElement), child, currentElement.Logic, false);
                    }
                }
                if (tagsContain(currentElement.Tags, "all"))
                {
                    parseCustomElement(getCurrentRoom(), getCurrentRoom(), currentElement.Logic, true);
                }
            }

            if (tagsContain(currentElement.Tags, "list") &&
                currentElement.Logic !== "")
            {
                parseListAction(currentElement);
            }

            if (tagsContain(currentElement.Tags, "spawn") &&
                currentElement.Logic !== "")
            {
                parseSpawnAction(currentElement);
            }
        }

        function parseAttack(currentElement, parsers)
        {
            currentEnemy = getTargets(currentElement, currentElement.Logic)?.[0] ?? null;
            showFightInterface();
        }

        function parseCustomElement(rootElement, parentElement, customType, isRecursive)
        {
            // Parent Level
            let custElems = database.filter(item => item.ElementType === customType &&
                item.ParentKey === parentElement.ElementKey);

            for (let elem of custElems)
            {
                parseElement(elem, generalParsers);
            }
           
            // Child Level
            let childElems = database.filter(item => canContainCustomElems.includes(item.ElementType) &&
                item.ParentKey === parentElement.ElementKey);

            for (let elem of childElems)
            {
                if (isRecursive || elem.ParentKey === rootElement.ElementKey)
                {
                    parseCustomElement(rootElement, elem, customType, isRecursive);
                }
            }
        }

        function parseInput(currentElement, parsers)
        {
            if (currentElement.Syntax === "")
            {
                return;
            }

            if (regexCheck(currentElement.Syntax, userInput.Input))
            {
                if (inputParsers.includes("logic") && !processLogic(currentElement))
                {
                    return;
                }

                gameOutput.InputMatchMade = true;
                parseElement(currentElement, inputParsers);
            }
        }

        function parseListAction(currentElement)
        {
            let caption = currentElement.Output;
            let items = getTargets(currentElement, currentElement.Logic);
            let pfx = "";
            gameOutput.Output = caption + "\n" + horizLine(caption) + "\n";
            for (let item of items)
            {
                if (tagsContain(item.Tags, armedTag))
                {
                    let wName = "";
                    const weapon = getArmedWeapon(getPlayer());
                    if (weapon === null)
                    {
                        wName = "Empty hand";
                    }
                    else
                    {
                        wName = weapon.Name;
                    }
                    gameOutput.Output += `${item.Name}: ${wName}`;
                    gameOutput.Output += "\n";
                    continue;
                }

                if (item.Output !== "")
                {
                    gameOutput.Output += `${item.Name}: ${item.Output}`;
                }
                else
                {
                    gameOutput.Output += `${item.Name}`;
                }
                gameOutput.Output += "\n";
            }
            gameOutput.ContinueParsing = false;
            gameOutput.MatchMade = true;
        }

        function processLogic(currentElement)
        {
            const children = getChildrenByType(currentElement, "logic");
            if (children === null || children.length < 1)
            {
                return true;
            }

            for (const child of children)
            {
                const passed = parseLogic(currentElement, child);
                if (!passed)
                {
                    return passed;
                }
            }

            return true;
        }
        function parseLogic(parentElement, childElement)
        {
            if (childElement.Logic === "")
            {
                return true;
            }
            let logicPassed = [];
            let logicRows = childElement.Logic.split(/\r?\n/);
            let curOperator = "and";
           
            for (let row of logicRows)
            {
                if (row.startsWith('?'))
                {
                    logicPassed.push(processLogicRow(parentElement, childElement, row.substring(1)));
                }
                else if (row.trim() === "and")
                {
                    curOperator = "and";
                }
                else if (row.trim() === "or")
                {
                    curOperator = "or";
                }

                if (logicPassed.length > 1)
                {
                    if (curOperator === "and" && logicPassed.includes(false))
                    {
                        return false;
                    }
                    if (curOperator === "or" && !logicPassed.includes(true))
                    {
                        return false;
                    }
                }
            }

            if (logicPassed.includes(false))
            {
                return false;
            }

            return true;
        }

        function parseSpawnAction(currentElement)
        {
            let spawnElem = database.find(item => item.ElementKey === currentElement.Logic) ?? null;
            if (spawnElem === null)
            {
                return;
            }
            let newParent = getTargets(currentElement, currentElement.Output)?.[0] ?? null;

            if (newParent === null)
            {
                return;
            }

            spawnElement(spawnElem, newParent);
        }

        function spawnElement(spawnElem, newParent)
        {
            let newKey = "";
            newParent = cloneElement(spawnElem, newParent.ElementKey);

            for (let spawnChild of getChildren(spawnElem, true))
            {
                spawnElement(spawnChild, newParent);
            }
        }

        function cloneElement(originalElement, newParentKey)
        {
            let entry = JSON.parse(JSON.stringify(originalElement));
            entry.ElementKey = getGuid();
            entry.ParentKey = newParentKey;

            database.push(entry);

            return entry;
        }

            /*

                LOGIC SYNTAX:

                -- operands --
                !=  Not equals to
                >=  Greater than or equal to
                <=  Less than or equal to
                !~~ Is not in
                ~~  Is in
                ><  Is outside the bounds
                <>  Is inside the bounds
                =   Is equal to
                >   Is greater than
                <   Is less than

                -- relative codes --
                [room]      The current room
                [player]    The player element
                [self]      This walks up to the first 'self' configured element - (See the SelfTypes.json file)
                [enemy]     While fighting

                -- special values --
                [children]                  Returns the child count of the [self] element
                [isday]                     Returns true if it is 'day time'
                [missiondays]               Displays how many days the player has been on the current mission (If any)
                [totaldays]                 Total in-game days that have passed
                rdm_<random expression>     Generates a random value to check against (So it doesn't always fire etc) (See Random Syntax)


                -- examples --
                ?(travel01)active = 'true'
                ?(player)((life)) > 0
                ?[self]active = 'true'
                ?[self]((is_discovered)) = 'true'
                ?[self]key ~~ ls(player)((inventory))key
                ?[self]key ~~ ls[room]((discoverable))key
                ?[self]key ~~ ls[room]((discoverable))children
                ?[self]children > 0
                ?(elem_by_key)children < 10
                ?[self]active = 'true'

            */
        function processLogicRow(parentElement, childElement, row)
        {
            let tag = "";
            let target1 = "";
            let field1 = "";
            let specCode1 = "";
            let value1 = "";
            let target2 = "";
            let field2 = "";
            let specCode2 = "";
            let value2 = "";
            let comparisons = splitLogicByOperand(row);
            let operand = getOperand(row);

            if (!Array.isArray(comparisons) || comparisons.length !== 2)
            {
                alert("Malformed logic statement!");
                return false;
            }

            if (operand === "")
            {
                return false;
            }

            value1 = getExplicitValue(comparisons[0]);
            value2 = getExplicitValue(comparisons[1]);

            if (value1 === "")
            {
                target1 = getTargets(childElement, comparisons[0])?.[0] ?? null;
                if (target1 === null)
                {
                    return;
                }
                field1 = getField(comparisons[0]);
                value1 = getFieldValue(target1, field1);
            }
            if (value2 === "")
            {
                target2 = getTargets(childElement, comparisons[1])?.[0] ?? null;
                if (target2 === null)
                {
                    return;
                }
                field2 = getField(comparisons[1]);
                value2 = getFieldValue(target2, field2);
            }

            return valueComparison(operand, value1, value2);
        }
        function splitLogicByOperand(row)
        {
            let splt = "";
            for (let oper of operands)
            {
                splt = row.split(oper);
                if (splt.length === 2)
                {
                    return splt;
                }
            }
        }
        function getOperand(row)
        {
            for (let op of operands)
            {
                if (row.includes(op))
                {
                    return op.trim();
                }
            }

            return "";
        }
        function getExplicitValue(row)
        {
            if (row.startsWith("'") && row.endsWith("'"))
            {
                return row.replaceAll("'", "");
            }
            return "";
        }
        function getFieldValue(curElem, field)
        {
            curElem = curElem;

            switch(field.toLowerCase())
            {
                case "elementtype":
                    return curElem.ElementType;
                case "elementkey":
                    return curElem.ElementKey;
                case "name":
                    return curElem.Name;
                case "parentkey":
                    return curElem.ParentKey;
                case "syntax":
                    return curElem.Syntax;
                case "logic":
                    return curElem.Logic;
                case "output":
                    return curElem.Output;
                case "parent":
                    return curElem.ParentKey;
                case "tags":
                    return curElem.Tags;
                default:
                    return "";
            }
        }
        function setFieldValue(curElem, field, value)
        {
            if (Array.isArray(curElem))
            {
                curElem = curElem[0];
            }

            switch(field.toLowerCase())
            {
                case "elementtype":
                    return curElem.ElementType = value;
                case "elementkey":
                    return curElem.ElementKey = value;
                case "name":
                    return curElem.Name = value;
                case "parentkey":
                    return curElem.ParentKey = value;
                case "syntax":
                    return curElem.Syntax = value;
                case "logic":
                    return curElem.Logic = value;
                case "output":
                    return curElem.Output = value;
                case "tags":
                    return curElem.Tags;
                default:
                    return "";
            }
        }
        function getTargets(childElement, row)
        {
            if (row.startsWith("<<"))
            {
                row = row.replace("<<", "").replace(">>", "");
            }
            let tgt = "";
            tgt = getTargetById(childElement, row);

            if (tgt === null)
            {
                tgt = getTargetsByRelCode(childElement, row);
            }

            if (row.endsWith("))"))
            {
                let arr = row.split("((");
                if (arr.length === 2)
                {
                    let tag = arr[1].replace("))", "");
                    tgt = getChildrenByTag(tgt, tag);
                }
            }

            return Array.isArray(tgt) ? tgt : [tgt];
        }
        function getTargetById(currentElement, row)
        {
            if (row.startsWith("[player]"))
            {
                return getPlayer();
            }
            if (row.startsWith("[room]"))
            {
                return getCurrentRoom();
            }
            if (row.startsWith("[self]"))
            {
                const self = getSelf(currentElement);
                if (self === null)
                {
                    return null;
                }
                return self;
            }
            if (row.startsWith("("))
            {
                row = row.substring(1);
                let arr = row.split(")");
                return getElementByKey(arr[0]);
            }

            return null;
        }
        function getTargetsByRelCode(childElement, row)
        {
            let parent = null;
            let childTag = "";
            let returnString = row;
            let relVal = "";

            if (Number.isInteger(Number(row)))
            {
                return row;
            }

            relVal = [...row.matchAll(/<<(.+?)>>/g)].map(match => match[1]);
            if (relVal === "undefined")
            {
                relVal = row;
            }
            if (relVal.length > 0)
            {
                relVal = relVal[0];
            }
            else
            {
                relVal = row;
            }

            if (relVal.startsWith("[self]"))
            {
                parent = getSelf(childElement);
            }
            if (relVal.startsWith("[room]"))
            {
                parent = getCurrentRoom();
            }
            if (relVal.startsWith("[player]"))
            {
                parent = getPlayer();
            }
            // TODO: Add GetEnemy

            let arr = relVal.split("))");
            if (arr.length === 2)
            {
                arr = arr[0].split("((");
                if (arr.length === 2)
                {
                    childTag = arr[1].trim();
                    return getChildrenByTag(parent, childTag);
                }
            }

            return parent;
        }
        function getTargetsBySyntax(input, parentElement)
        {
            const roomChildren = getChildren(parentElement, false);

            for (let child of roomChildren)
            {
                if (regexCheck(child.Syntax, input))
                {
                    return child;
                }

                return getTargetsBySyntax(input, child);
            }

            return null;
        }
        function getField(row)
        {
            let arr = "";

            if (row.endsWith("]") || row.endsWith("))") || row.endsWith(")"))
            {
                return "Output";
            }

            arr = row.split("]");
            if (arr.length !== 2)
            {
                arr = row.split(")");
            }

            if (arr.length === 2)
            {
                return arr[1].trim();
            }

            return "Output";
        }
        function valueComparison(operand, val1, val2)
        {
            switch (operand.trim())
            {
                case "!=":
                    if (val1 !== val2)
                    {
                        return true;
                    }
                    break;
                case ">=":
                    if (val1 >= val2)
                    {
                        return true;
                    }
                    break;
                case "<=":
                    if (val1 <= val2)
                    {
                        return true;
                    }
                    break;

                case "!~~":
                    return !val2.includes(val1);
                case "~~":
                    return val2.includes(val1);
                case "><":
                    return val1 < val2 || val1 > val2;
                case "<>":
                    return val1 > val2 && val1 < val2;
                case "=":
                    return val1 === val2;
                case ">":
                    return val1 > val2;
                case "<":
                    return val1 < val2
            }

            return false;
        }

        function parseGlobal(parsers)
        {
            let globalElems = getElementsByType("global");

            for (let glob of globalElems)
            {
                for (let prsr of parsers)
                {
                    for (let child of getChildren(glob, false))
                    {
                        callParser(prsr, glob, child, false);
                    }
                }
            }
        }

        function parseMessage(parentElement, childElement)
        {
            const msgs = database.filter(item => item.ParentKey === childElement.ElementKey);
            if (msgs === null || msgs.length < 1)
            {
                if (childElement.Output === "")
                {
                    return;
                }
                outputMatch(childElement.Output, true);
                return;
            }

            if (childElement.Repeat === null || childElement.Repeat === "")
            {
                childElement.Repeat = "repeat";
            }

            switch (childElement.Repeat)
            {
                case "random":
                    if (msgs === null || msgs.length < 1)
                    {
                        return;
                    }
                    const rndLen = msgs.length;
                    const rndIdx = getRandomByRange(0, rndLen - 1);
                    outputMatch(msgs[rndIdx].Output, true);
                    break;
                case "repeat":
                    const rptLen = msgs.length;
                    let rptIdx = parentElement.RepeatIndex;
                    if (rptIdx === "")
                    {
                        rptIdx = -1;
                    }
                    if (rptIdx > rptLen - 1)
                    {
                        rptIdx = 0;
                    }
                    outputMatch(msgs[rptIdx].Output, true);
                    rptIdx = parseInt(rptIdx) + 1;
                    parentElement.RepeatIndex = rptIdx;
                    break;
                case "none":
                    const nLen = msgs.length;
                    let nIdx = parentElement.RepeatIndex;
                    if (nIdx === "")
                    {
                        nIdx = -1;
                    }
                    if (nIdx > nLen - 1)
                    {
                        nIdx = (nLen - 1);
                    }
                    outputMatch(msgs[nIdx].Output, true);
                    if (nIdx < (nLen -1))
                    {
                        nIdx = parseInt(nIdx) + 1;
                    }
                    parentElement.RepeatIndex = nIdx;
                    break;
                default:
                    const tgt = getTargets(childElement, childElement.Repeat)?.[0] ?? null;
                    if (tgt === null)
                    {
                        return;
                    }
                    const otherIndex = getFieldValue(tgt, getField(childElement.Repeat));
                    try
                    {
                        parentElement.RepeatIndex = parseInt(otherIndex);
                    }
                    catch (Exception)
                    {
                        parentElement.RepeatIndex = -1;
                    }
                    outputMatch(msgs[parentElement.RepeatIndex].Output, true);
                    break;
            }
        }

        function parseMove(currentElement, parsers)
        {
            let outputText = "";
            let targetKey = "";
            let targetElem = null;

            if (currentElement.Logic !== limboValue)
            {
                targetElem = getElement(currentElement.Logic, currentElement);
                if (targetElem === null)
                {
                    return;
                }
                targetKey = targetElem.ElementKey;
            }
            else
            {
                targetKey = limboValue;
            }

            let movingElem = getElement(currentElement.Tags, currentElement);

            if (movingElem != null && targetKey !== "")
            {
                const player = getPlayer();
                const currentParent = movingElem.ParentKey;
                movingElem.ParentKey = targetKey;
                if (currentParent === player.ElementKey && targetKey !== player.ElementKey)
                {
                    setDefaultWeapon(movingElem.ElementKey);
                }
                gameOutput.MatchMade = true;
                if (currentElement.Output !== "" && outputText === "")
                {
                    gameOutput.Output = currentElement.Output.replace("[target]", movingElem.Name);
                    gameOutput.MatchMade = true;
                    gameOutput.ContinueParsing = false;
                }
                else
                {
                    outputMatch(currentElement.Output, false);
                }
                if (movingElem.ElementType === "player")
                {
                    gameOutput.EnterMsgDone = false;
                    parseRoom(roomParsers, true);
                    return;
                }
            }
        }

        function parseNpc(parentElement, currentElement, parsers, isEntering)
        {
            if (npcParsers.includes("logic") && !processLogic(currentElement))
            {
                return;
            }

            for (let prsr of parsers)
            {
                for (let child of getChildren(currentElement, false))
                {
                    callParser(prsr, currentElement, child, isEntering);
                }
            }
        }

        function parseObject(parentElement, currentElement, parsers, isEntering)
        {
            if (objectParsers.includes("logic") && !processLogic(currentElement))
            {
                return;
            }

            for (let prsr of parsers)
            {
                for (let child of getChildren(currentElement, false))
                {
                    callParser(prsr, currentElement, child, isEntering);
                }
            }
        }

        function parseRoom(parsers, isEntering)
        {
            let roomElem = getCurrentRoom();

            for (let prsr of parsers)
            {
                for (let child of getChildren(roomElem, isEntering))
                {
                    callParser(prsr, roomElem, child, isEntering);
                }
            }

            if (parsers.includes("navigation") && roomElem.ElementKey === getPlayer().ParentKey)
            {
                const navs = getChildrenByType(roomElem, "navigation");
                if (navs === null || navs.length < 1)
                {
                    return;
                }
                for (const nav of navs)
                {
                    const doContinue = gameOutput.ContinueParsing;
                    gameOutput.ContinueParsing = true;
                    parseElement(nav, navigationParsers); 
                    gameOutput.ContinueParsing = doContinue;
                }
            }
        }

        function parsePlayer(parsers)
        {
            let playerElem = getPlayer();
            const isEntering = false;

            for (let prsr of parsers)
            {
                for (let child of getChildren(playerElem, isEntering))
                {
                    callParser(prsr, playerElem, child, isEntering);

                    if (child.ElementType === "object")
                    {
                        for (let objChild of getChildren(child, isEntering))
                        {
                            callParser(prsr, child, objChild, isEntering);
                        }
                    }
                }
            }
        }

        function parseSet(parentElement, currentElement, parsers)
        {
            if (setParsers.includes("logic") && !processLogic(currentElement))
            {
                return;
            }

            if (tagsContain(currentElement.Tags, "arm"))
            {
                let target = getChildrenBySyntax(getPlayer(), userInput.Input);
                if (target === null || target.length < 1)
                {
                    gameOutput.Output = "You aren't carrying that weapon.";
                    gameOutput.MatchMade = true;
                    return;
                }
                if (!tagsContain(target.Tags, weaponTag))
                {
                    gameOutput.Output = "That is not a weapon.";
                    gameOutput.MatchMade = true;
                    return;
                }
                if (Array.isArray(target))
                {
                    target = target[0];
                }

                setPlayerArmed(target.ElementKey);
                const title = getChildByTag(target, "title");

                gameOutput.Output = `You are now armed with ${title.Output}.`;
                gameOutput.MatchMade = true;
                return;
            }

            let field = "";
            let tgt = getTargets(currentElement, currentElement.Logic)?.[0] ?? null;
            if (tgt === null)
            {
                return;
            }
            field = getField(currentElement.Logic);

            updateElementField(tgt, field, currentElement.Output);
        }

        function updateElementField(currentElement, fieldName, newValue)
        {
            let curValue = getFieldValue(currentElement, fieldName);

            if (newValue.startsWith("+="))
            {
                let inc = Number(newValue.replace("+=", ""));
                curValue = Number(curValue) + inc;
            }
            if (newValue.startsWith("-="))
            {
                let dec = Number(newValue.replace("-=", ""));
                curValue = Number(curValue) - dec;
            }
            if (newValue === "++")
            {
                curValue = Number(curValue) + 1;
            }
            if (newValue === "--")
            {
                curValue = Number(curValue) - 1;
            }

            if (curValue === "")
            {
                curValue = newValue;
            }

            switch(fieldName.toLowerCase())
            {
                case "active":
                    currentElement.Active = curValue;
                    break;
                case "elementtype":
                    currentElement.ElementType = curValue;
                    break;
                case "elementkey":
                    currentElement.ElementKey = curValue;
                    break;
                case "name":
                    currentElement.Name = curValue;
                    break;
                case "parentkey":
                    currentElement.ParentKey = curValue;
                    break;
                case "syntax":
                    currentElement.Syntax = curValue;
                    break;
                case "logic":
                    currentElement.Logic = curValue;
                    break;
                case "output":
                    currentElement.Output = curValue;
                    break;
                case "tags":
                    if (newValue.startsWith("+"))
                    {
                        addTag(currentElement, newValue.substring(1));
                    }
                    if (newValue.startsWith("-"))
                    {
                        removeTag(currentElement, newValue.substring(1));
                    }
                    break;
            }
        }

        function parseElement(parentElement, parsers)
        {
            if (!gameOutput.ContinueParsing)
            {
                return;
            }

            for (let prsr of parsers)
            {
                for (let child of getChildren(parentElement, false))
                {
                    callParser(prsr, parentElement, child, false);
                    if (!gameOutput.ContinueParsing)
                    {
                        return;
                    }
                }
            }
        }

        // Parser managing function
        function callParser(curParser, parentElement, childElement, isEntering)
        {
            if (childElement.ElementType !== curParser)
            {
                return;
            }

            switch (curParser)
            {
                case "action":
                    parseAction(childElement, actionParsers);
                    break;

                case "attack":
                    parseAttack(childElement, attackParsers);
                    break;

                case "enter_message":
                    if (parentElement.ElementType !== "game" &&
                        isEntering &&
                        !gameOutput.EnterMsgDone
                    )
                    {
                        if (parseLogic(parentElement, childElement))
                        {
                            outputMatch(childElement.Output, true);
                        }
                        followPlayer();
                    }
                    break;

                case "input":
                    if (!gameOutput.InputMatchMade)
                    {
                        parseInput(childElement, inputParsers);
                    }
                    break;

                case "message":
                    if (messageParsers.includes("logic") && !processLogic(childElement))
                    {
                        return;
                    }

                    if (parentElement.ElementType !== "game")
                    {
                        parseMessage(parentElement, childElement);
                    }
                    break;

                case "move":
                    if (moveParsers.includes("logic") && !processLogic(childElement))
                    {
                        return;
                    }

                    parseMove(childElement, moveParsers);
                    if (!gameOutput.ContinueParsing)
                    {
                        return;
                    }
                    break;

                case "npc":
                    parseNpc(parentElement, childElement, objectParsers, isEntering);

                    for (let npcChild of getChildren(childElement))
                    {
                        callParser(curParser, childElement, npcChild, isEntering);
                    }
                    break;

                case "object":
                    parseObject(parentElement, childElement, objectParsers, isEntering);

                    for (let objChild of getChildren(childElement))
                    {
                        callParser(curParser, childElement, objChild, isEntering);
                    }
                    break;

                case "set":
                    parseSet(parentElement, childElement, setParsers);
                    break;
            }
        }
    </script>
</body></html>
